/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Camunda Platform REST API
 * OpenApi Spec for Camunda Platform REST API.
 *
 * OpenAPI spec version: 7.13.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://{host}:{port}/{contextPath}".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * A JSON object corresponding to the Activity Instance tree of the given process instance.
 * @export
 * @interface ActivityInstanceDto
 */
export interface ActivityInstanceDto {
    /**
     * The id of the activity instance.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    id?: string;
    /**
     * The id of the parent activity instance, for example a sub process instance.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    parentActivityInstanceId?: string;
    /**
     * The id of the activity.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    activityId?: string;
    /**
     * The name of the activity
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    activityName?: string;
    /**
     * The type of activity (corresponds to the XML element name in the BPMN 2.0, e.g., 'userTask')
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    activityType?: string;
    /**
     * The id of the process instance this activity instance is part of.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    processInstanceId?: string;
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof ActivityInstanceDto
     */
    processDefinitionId?: string;
    /**
     * A list of child activity instances.
     * @type {Array<ActivityInstanceDto>}
     * @memberof ActivityInstanceDto
     */
    childActivityInstances?: Array<ActivityInstanceDto>;
    /**
     * A list of child transition instances. A transition instance represents an execution waiting in an asynchronous continuation.
     * @type {Array<TransitionInstanceDto>}
     * @memberof ActivityInstanceDto
     */
    childTransitionInstances?: Array<TransitionInstanceDto>;
    /**
     * A list of execution ids.
     * @type {Array<string>}
     * @memberof ActivityInstanceDto
     */
    executionIds?: Array<string>;
    /**
     * A list of incident ids.
     * @type {Array<string>}
     * @memberof ActivityInstanceDto
     */
    incidentIds?: Array<string>;
    /**
     * A list of JSON objects containing incident specific properties: * `id`: the id of the incident * `activityId`: the activity id in which the incident occurred
     * @type {Array<ActivityInstanceIncidentDto>}
     * @memberof ActivityInstanceDto
     */
    incidents?: Array<ActivityInstanceIncidentDto>;
}
/**
 * An activity instance, incident pair.
 * @export
 * @interface ActivityInstanceIncidentDto
 */
export interface ActivityInstanceIncidentDto {
    /**
     * The id of the incident.
     * @type {string}
     * @memberof ActivityInstanceIncidentDto
     */
    id?: string;
    /**
     * The activity id in which the incident happened.
     * @type {string}
     * @memberof ActivityInstanceIncidentDto
     */
    parentActivityInstanceId?: string;
}
/**
 * 
 * @export
 * @interface ActivityStatisticsResultDto
 */
export interface ActivityStatisticsResultDto {
    /**
     * The id of the activity the results are aggregated for.
     * @type {string}
     * @memberof ActivityStatisticsResultDto
     */
    id?: string;
    /**
     * The total number of running process instances of this activity.
     * @type {number}
     * @memberof ActivityStatisticsResultDto
     */
    instances?: number;
    /**
     * The total number of failed jobs for the running instances. **Note**: Will be `0` (not `null`), if failed jobs were excluded.
     * @type {number}
     * @memberof ActivityStatisticsResultDto
     */
    failedJobs?: number;
    /**
     * Each item in the resulting array is an object which contains `incidentType` and `incidentCount`. **Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded. Furthermore, the array will be also empty if no incidents were found.
     * @type {Array<IncidentStatisticsResultDto>}
     * @memberof ActivityStatisticsResultDto
     */
    incidents?: Array<IncidentStatisticsResultDto>;
}
/**
 * 
 * @export
 * @interface AtomLink
 */
export interface AtomLink {
    /**
     * The relation of the link to the object that belogs to.
     * @type {string}
     * @memberof AtomLink
     */
    rel?: string;
    /**
     * The url of the link.
     * @type {string}
     * @memberof AtomLink
     */
    href?: string;
    /**
     * The http method.
     * @type {string}
     * @memberof AtomLink
     */
    method?: string;
}
/**
 * 
 * @export
 * @interface AttachmentDto
 */
export interface AttachmentDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof AttachmentDto
     */
    links?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface AuthorizationExceptionDto
 */
export interface AuthorizationExceptionDto {
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof AuthorizationExceptionDto
     */
    type?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof AuthorizationExceptionDto
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface BatchDto
 */
export interface BatchDto {
    /**
     * The id of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    id?: string;
    /**
     * The type of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    type?: string;
    /**
     * The total jobs of a batch is the number of batch execution jobs required to complete the batch.
     * @type {number}
     * @memberof BatchDto
     */
    totalJobs?: number;
    /**
     * The number of batch execution jobs already created by the seed job.
     * @type {number}
     * @memberof BatchDto
     */
    jobsCreated?: number;
    /**
     * The number of batch execution jobs created per seed job invocation. The batch seed job is invoked until it has created all batch execution jobs required by the batch (see totalJobs property).
     * @type {number}
     * @memberof BatchDto
     */
    batchJobsPerSeed?: number;
    /**
     * Every batch execution job invokes the command executed by the batch invocationsPerBatchJob times. E.g., for a process instance migration batch this specifies the number of process instances which are migrated per batch execution job.
     * @type {number}
     * @memberof BatchDto
     */
    invocationsPerBatchJob?: number;
    /**
     * The job definition id for the seed jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    seedJobDefinitionId?: string;
    /**
     * The job definition id for the monitor jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    monitorJobDefinitionId?: string;
    /**
     * The job definition id for the batch execution jobs of this batch.
     * @type {string}
     * @memberof BatchDto
     */
    batchJobDefinitionId?: string;
    /**
     * Indicates whether this batch is suspended or not.
     * @type {boolean}
     * @memberof BatchDto
     */
    suspended?: boolean;
    /**
     * The tenant id of the batch.
     * @type {string}
     * @memberof BatchDto
     */
    tenantId?: string;
    /**
     * The id of the user that created the batch.
     * @type {string}
     * @memberof BatchDto
     */
    createUserId?: string;
}
/**
 * 
 * @export
 * @interface CaseDefinitionDto
 */
export interface CaseDefinitionDto {
    /**
     * The id of the case definition
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    id?: string;
    /**
     * The key of the case definition, i.e., the id of the CMMN 2.0 XML case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    key?: string;
    /**
     * The category of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    category?: string;
    /**
     * The name of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    name?: string;
    /**
     * The version of the case definition that the engine assigned to it.
     * @type {number}
     * @memberof CaseDefinitionDto
     */
    version?: number;
    /**
     * The file name of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    resource?: string;
    /**
     * The deployment id of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    deploymentId?: string;
    /**
     * The tenant id of the case definition.
     * @type {string}
     * @memberof CaseDefinitionDto
     */
    tenantId?: string;
    /**
     * History time to live value of the case definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof CaseDefinitionDto
     */
    historyTimeToLive?: number;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof CommentDto
     */
    links?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface CompleteExternalTaskDto
 */
export interface CompleteExternalTaskDto {
    /**
     * The id of the worker that completes the task. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof CompleteExternalTaskDto
     */
    workerId?: string;
    /**
     * A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteExternalTaskDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * A JSON object containing local variable key-value pairs. Local variables are set only in the scope of external task. Each key is a variable name and each value a JSON variable value object with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteExternalTaskDto
     */
    localVariables?: { [key: string]: VariableValueDto; };
}
/**
 * 
 * @export
 * @interface CompleteTaskDto
 */
export interface CompleteTaskDto {
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CompleteTaskDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * Indicates whether the response should contain the process variables or not. The default is `false` with a response code of `204`. If set to `true` the response contains the process variables and has a response code of `200`. If the task is not associated with a process instance (e.g. if it's part of a case instance) no variables will be returned.
     * @type {boolean}
     * @memberof CompleteTaskDto
     */
    withVariablesInReturn?: boolean;
}
/**
 * 
 * @export
 * @interface CorrelationMessageDto
 */
export interface CorrelationMessageDto {
    /**
     * The name of the message to deliver.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    messageName?: string;
    /**
     * Used for correlation of process instances that wait for incoming messages. Will only correlate to executions that belong to a process instance with the provided business key.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    businessKey?: string;
    /**
     * Used to correlate the message for a tenant with the given id. Will only correlate to executions and process definitions which belong to the tenant. Must not be supplied in conjunction with a `withoutTenantId`.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    tenantId?: string;
    /**
     * A Boolean value that indicates whether the message should only be correlated to executions and process definitions which belong to no tenant or not. Value may only be `true`, as `false` is the default behavior. Must not be supplied in conjunction with a `tenantId`.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    withoutTenantId?: boolean;
    /**
     * Used to correlate the message to the process instance with the given id.
     * @type {string}
     * @memberof CorrelationMessageDto
     */
    processInstanceId?: string;
    /**
     * Used for correlation of process instances that wait for incoming messages. Has to be a JSON object containing key-value pairs that are matched against process instance variables during correlation. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    correlationKeys?: { [key: string]: VariableValueDto; };
    /**
     * Local variables used for correlation of executions (process instances) that wait for incoming messages. Has to be a JSON object containing key-value pairs that are matched against local variables during correlation. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    localCorrelationKeys?: { [key: string]: VariableValueDto; };
    /**
     * A map of variables that is injected into the triggered execution or process instance after the message has been delivered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    processVariables?: { [key: string]: VariableValueDto; };
    /**
     * A map of local variables that is injected into the triggered execution or process instance after the message has been delivered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof CorrelationMessageDto
     */
    processVariablesLocal?: { [key: string]: VariableValueDto; };
    /**
     * A Boolean value that indicates whether the message should be correlated to exactly one entity or multiple entities. If the value is set to `false`, the message will be correlated to exactly one entity (execution or process definition). If the value is set to `true`, the message will be correlated to multiple executions and a process definition that can be instantiated by this message in one go.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    all?: boolean;
    /**
     * A Boolean value that indicates whether the result of the correlation should be returned or not. If this property is set to `true`, there will be returned a list of message correlation result objects. Depending on the all property, there will be either one ore more returned results in the list.  The default value is `false`, which means no result will be returned.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    resultEnabled?: boolean;
    /**
     * A Boolean value that indicates whether the result of the correlation should contain process variables or not. The parameter resultEnabled should be set to `true` in order to use this it.  The default value is `false`, which means the variables will not be returned.
     * @type {boolean}
     * @memberof CorrelationMessageDto
     */
    variablesInResultEnabled?: boolean;
}
/**
 * 
 * @export
 * @interface CountResultDto
 */
export interface CountResultDto {
    /**
     * The number of matching instances.
     * @type {number}
     * @memberof CountResultDto
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface DecisionDefinitionDto
 */
export interface DecisionDefinitionDto {
    /**
     * The id of the decision definition
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    id?: string;
    /**
     * The key of the decision definition, i.e., the id of the DMN 1.0 XML decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    key?: string;
    /**
     * The category of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    category?: string;
    /**
     * The name of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    name?: string;
    /**
     * The version of the decision definition that the engine assigned to it.
     * @type {number}
     * @memberof DecisionDefinitionDto
     */
    version?: number;
    /**
     * The file name of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    resource?: string;
    /**
     * The deployment id of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    deploymentId?: string;
    /**
     * The tenant id of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    tenantId?: string;
    /**
     * The id of the decision requirements definition this decision definition belongs to.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    decisionRequirementsDefinitionId?: string;
    /**
     * The key of the decision requirements definition this decision definition belongs to.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    decisionRequirementsDefinitionKey?: string;
    /**
     * History time to live value of the decision definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof DecisionDefinitionDto
     */
    historyTimeToLive?: number;
    /**
     * The version tag of the decision definition.
     * @type {string}
     * @memberof DecisionDefinitionDto
     */
    versionTag?: string;
}
/**
 * 
 * @export
 * @interface DecisionRequirementsDefinitionDto
 */
export interface DecisionRequirementsDefinitionDto {
    /**
     * The id of the decision requirements definition
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    id?: string;
    /**
     * The key of the decision requirements definition, i.e., the id of the DMN 1.0 XML decision definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    key?: string;
    /**
     * The name of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    name?: string;
    /**
     * The category of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    category?: string;
    /**
     * The version of the decision requirements definition that the engine assigned to it.
     * @type {number}
     * @memberof DecisionRequirementsDefinitionDto
     */
    version?: number;
    /**
     * The file name of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    resource?: string;
    /**
     * The deployment id of the decision requirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    deploymentId?: string;
    /**
     * The tenant id of the decisionrequirements definition.
     * @type {string}
     * @memberof DecisionRequirementsDefinitionDto
     */
    tenantId?: string;
}
/**
 * 
 * @export
 * @interface DeleteProcessInstancesDto
 */
export interface DeleteProcessInstancesDto {
    /**
     * A list process instance ids to delete.
     * @type {Array<string>}
     * @memberof DeleteProcessInstancesDto
     */
    processInstanceIds?: Array<string>;
    /**
     * A string with delete reason.
     * @type {string}
     * @memberof DeleteProcessInstancesDto
     */
    deleteReason?: string;
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof DeleteProcessInstancesDto
     */
    skipCustomListeners?: boolean;
    /**
     * Skip deletion of the subprocesses related to deleted processes as part of this request.
     * @type {boolean}
     * @memberof DeleteProcessInstancesDto
     */
    skipSubprocesses?: boolean;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof DeleteProcessInstancesDto
     */
    processInstanceQuery?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof DeleteProcessInstancesDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface DeploymentDto
 */
export interface DeploymentDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof DeploymentDto
     */
    links?: Array<AtomLink>;
}
/**
 * A JSON object corresponding to the `Resource` interface in the engine. Its properties are as follows:
 * @export
 * @interface DeploymentResourceDto
 */
export interface DeploymentResourceDto {
    /**
     * The id of the deployment resource.
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    id?: string;
    /**
     * The name of the deployment resource
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    name?: string;
    /**
     * The id of the deployment.
     * @type {string}
     * @memberof DeploymentResourceDto
     */
    deploymentId?: string;
}
/**
 * 
 * @export
 * @interface DeploymentWithDefinitionsDto
 */
export interface DeploymentWithDefinitionsDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof DeploymentWithDefinitionsDto
     */
    links?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface EvaluationConditionDto
 */
export interface EvaluationConditionDto {
    /**
     * A map of variables which are used for evaluation of the conditions and are injected into the process instances which have been triggered. Each key is a variable name and each value a JSON variable value object with the following properties.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof EvaluationConditionDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * Used for the process instances that have been triggered after the evaluation.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    businessKey?: string;
    /**
     * Used to evaluate a condition for a tenant with the given id. Will only evaluate conditions of process definitions which belong to the tenant.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    tenantId?: string;
    /**
     * A Boolean value that indicates whether the conditions should only be evaluated of process definitions which belong to no tenant or not. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof EvaluationConditionDto
     */
    withoutTenantId?: boolean;
    /**
     * Used to evaluate conditions of the process definition with the given id.
     * @type {string}
     * @memberof EvaluationConditionDto
     */
    processDefinitionId?: string;
}
/**
 * 
 * @export
 * @interface EventSubscriptionDto
 */
export interface EventSubscriptionDto {
    /**
     * The id of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    id?: string;
    /**
     * The type of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    eventType?: string;
    /**
     * The name of the event this subscription belongs to as defined in the process model.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    eventName?: string;
    /**
     * The execution that is subscribed on the referenced event.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    executionId?: string;
    /**
     * The process instance this subscription belongs to.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    processInstanceId?: string;
    /**
     * The identifier of the activity that this event subscription belongs to. This could for example be the id of a receive task.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    activityId?: string;
    /**
     * The time this event subscription was created.
     * @type {Date}
     * @memberof EventSubscriptionDto
     */
    createdDate?: Date;
    /**
     * The id of the tenant this event subscription belongs to. Can be `null` if the subscription belongs to no single tenant.
     * @type {string}
     * @memberof EventSubscriptionDto
     */
    tenantId?: string;
}
/**
 * A event subscription query which retrieves a list of event subscriptions
 * @export
 * @interface EventSubscriptionQueryDto
 */
export interface EventSubscriptionQueryDto {
    /**
     * The id of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    eventSubscriptionId?: string;
    /**
     * The name of the event this subscription belongs to as defined in the process model.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    eventName?: string;
    /**
     * The type of the event subscription.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    eventType?: EventSubscriptionQueryDto.EventTypeEnum;
    /**
     * The execution that is subscribed on the referenced event.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    executionId?: string;
    /**
     * The process instance this subscription belongs to.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    processInstanceId?: string;
    /**
     * The identifier of the activity that this event subscription belongs to. This could for example be the id of a receive task.
     * @type {string}
     * @memberof EventSubscriptionQueryDto
     */
    activityId?: string;
    /**
     * Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @type {Array<string>}
     * @memberof EventSubscriptionQueryDto
     */
    tenantIdIn?: Array<string>;
    /**
     * Only select subscriptions which have no tenant id. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof EventSubscriptionQueryDto
     */
    withoutTenantId?: boolean;
    /**
     * Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof EventSubscriptionQueryDto
     */
    includeEventSubscriptionsWithoutTenantId?: boolean;
    /**
     * Apply sorting of the result
     * @type {Array<EventSubscriptionQueryDtoSorting>}
     * @memberof EventSubscriptionQueryDto
     */
    sorting?: Array<EventSubscriptionQueryDtoSorting>;
}

/**
 * @export
 * @namespace EventSubscriptionQueryDto
 */
export namespace EventSubscriptionQueryDto {
    /**
     * @export
     * @enum {string}
     */
    export enum EventTypeEnum {
        Message = <any> 'message',
        Signal = <any> 'signal',
        Compensate = <any> 'compensate',
        Conditional = <any> 'conditional'
    }
}
/**
 * 
 * @export
 * @interface EventSubscriptionQueryDtoSorting
 */
export interface EventSubscriptionQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof EventSubscriptionQueryDtoSorting
     */
    sortBy?: EventSubscriptionQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof EventSubscriptionQueryDtoSorting
     */
    sortOrder?: EventSubscriptionQueryDtoSorting.SortOrderEnum;
}

/**
 * @export
 * @namespace EventSubscriptionQueryDtoSorting
 */
export namespace EventSubscriptionQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        Created = <any> 'created',
        TenantId = <any> 'tenantId'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface ExceptionDto
 */
export interface ExceptionDto {
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof ExceptionDto
     */
    type?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof ExceptionDto
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface ExecutionDto
 */
export interface ExecutionDto {
    /**
     * The id of the Execution.
     * @type {string}
     * @memberof ExecutionDto
     */
    id?: string;
    /**
     * The id of the root of the execution tree representing the process instance.
     * @type {string}
     * @memberof ExecutionDto
     */
    processInstanceId?: string;
    /**
     * Indicates if the execution is ended.
     * @type {boolean}
     * @memberof ExecutionDto
     */
    ended?: boolean;
    /**
     * The id of the tenant this execution belongs to. Can be `null` if the execution belongs to no single tenant.
     * @type {string}
     * @memberof ExecutionDto
     */
    tenantId?: string;
}
/**
 * 
 * @export
 * @interface ExtendLockOnExternalTaskDto
 */
export interface ExtendLockOnExternalTaskDto {
    /**
     * The ID of a worker who is locking the external task.
     * @type {string}
     * @memberof ExtendLockOnExternalTaskDto
     */
    workerId?: string;
    /**
     * An amount of time (in milliseconds). This is the new lock duration starting from the current moment.
     * @type {number}
     * @memberof ExtendLockOnExternalTaskDto
     */
    newDuration?: number;
}
/**
 * 
 * @export
 * @interface ExternalTaskBpmnError
 */
export interface ExternalTaskBpmnError {
    /**
     * An error code that indicates the predefined error. It is used to identify the BPMN error handler.
     * @type {string}
     * @memberof ExternalTaskBpmnError
     */
    errorCode?: string;
    /**
     * An error message that describes the error.
     * @type {string}
     * @memberof ExternalTaskBpmnError
     */
    errorMessage?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof ExternalTaskBpmnError
     */
    variables?: { [key: string]: VariableValueDto; };
}
/**
 * An External Task object with the following properties
 * @export
 * @interface ExternalTaskDto
 */
export interface ExternalTaskDto {
    /**
     * The id of the activity that this external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    activityId?: string;
    /**
     * The id of the activity instance that the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    activityInstanceId?: string;
    /**
     * The full error message submitted with the latest reported failure executing this task; `null` if no failure was reported previously or if no error message was submitted
     * @type {string}
     * @memberof ExternalTaskDto
     */
    errorMessage?: string;
    /**
     * The id of the execution that the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    executionId?: string;
    /**
     * The id of the external task.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    id?: string;
    /**
     * The date that the task's most recent lock expires or has expired.
     * @type {Date}
     * @memberof ExternalTaskDto
     */
    lockExpirationTime?: Date;
    /**
     * The id of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    processDefinitionId?: string;
    /**
     * The key of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    processDefinitionKey?: string;
    /**
     * The version tag of the process definition the external task is defined in.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    processDefinitionVersionTag?: string;
    /**
     * The id of the process instance the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    processInstanceId?: string;
    /**
     * The id of the tenant the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    tenantId?: string;
    /**
     * The number of retries the task currently has left.
     * @type {number}
     * @memberof ExternalTaskDto
     */
    retries?: number;
    /**
     * A flag indicating whether the external task is suspended or not.
     * @type {boolean}
     * @memberof ExternalTaskDto
     */
    suspended?: boolean;
    /**
     * The id of the worker that posesses or posessed the most recent lock.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    workerId?: string;
    /**
     * The topic name of the external task.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    topicName?: string;
    /**
     * The priority of the external task.
     * @type {number}
     * @memberof ExternalTaskDto
     */
    priority?: number;
    /**
     * The business key of the process instance the external task belongs to.
     * @type {string}
     * @memberof ExternalTaskDto
     */
    businessKey?: string;
}
/**
 * 
 * @export
 * @interface ExternalTaskFailureDto
 */
export interface ExternalTaskFailureDto {
    /**
     * The id of the worker that reports the failure. Must match the id of the worker who has most recently locked the task.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    workerId?: string;
    /**
     * An message indicating the reason of the failure.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    errorMessage?: string;
    /**
     * A detailed error description.
     * @type {string}
     * @memberof ExternalTaskFailureDto
     */
    errorDetails?: string;
    /**
     * A number of how often the task should be retried. Must be >= 0. If this is 0, an incident is created and the task cannot be fetched anymore unless the retries are increased again. The incident's message is set to the `errorMessage` parameter.
     * @type {number}
     * @memberof ExternalTaskFailureDto
     */
    retries?: number;
    /**
     * A timeout in milliseconds before the external task becomes available again for fetching. Must be >= 0.
     * @type {number}
     * @memberof ExternalTaskFailureDto
     */
    retryTimeout?: number;
}
/**
 * A JSON object with the following properties:
 * @export
 * @interface ExternalTaskQueryDto
 */
export interface ExternalTaskQueryDto {
    /**
     * Filter by an external task's id.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    externalTaskId?: string;
    /**
     * Filter by the comma-separated list of external task ids.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    externalTaskIdIn?: Array<string>;
    /**
     * Filter by an external task topic.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    topicName?: string;
    /**
     * Filter by the id of the worker that the task was most recently locked by.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    workerId?: string;
    /**
     * Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    locked?: boolean;
    /**
     * Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    notLocked?: boolean;
    /**
     * Only include external tasks that have a positive (&gt; 0) number of retries (or `null`). Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    withRetriesLeft?: boolean;
    /**
     * Only include external tasks that have 0 retries. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    noRetriesLeft?: boolean;
    /**
     * Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.
     * @type {Date}
     * @memberof ExternalTaskQueryDto
     */
    lockExpirationAfter?: Date;
    /**
     * Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.000+0200`.
     * @type {Date}
     * @memberof ExternalTaskQueryDto
     */
    lockExpirationBefore?: Date;
    /**
     * Filter by the id of the activity that an external task is created for.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    activityId?: string;
    /**
     * Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    activityIdIn?: Array<string>;
    /**
     * Filter by the id of the execution that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    executionId?: string;
    /**
     * Filter by the id of the process instance that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    processInstanceId?: string;
    /**
     * Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    processInstanceIdIn?: Array<string>;
    /**
     * Filter by the id of the process definition that an external task belongs to.
     * @type {string}
     * @memberof ExternalTaskQueryDto
     */
    processDefinitionId?: string;
    /**
     * Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @type {Array<string>}
     * @memberof ExternalTaskQueryDto
     */
    tenantIdIn?: Array<string>;
    /**
     * Only include active tasks. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    active?: boolean;
    /**
     * Only include suspended tasks. Value may only be `true`, as `false` matches any external task.
     * @type {boolean}
     * @memberof ExternalTaskQueryDto
     */
    suspended?: boolean;
    /**
     * Only include jobs with a priority higher than or equal to the given value. Value must be a valid `long` value.
     * @type {number}
     * @memberof ExternalTaskQueryDto
     */
    priorityHigherThanOrEquals?: number;
    /**
     * Only include jobs with a priority lower than or equal to the given value. Value must be a valid `long` value.
     * @type {number}
     * @memberof ExternalTaskQueryDto
     */
    priorityLowerThanOrEquals?: number;
    /**
     * A JSON array of criteria to sort the result by. Each element of the array is a JSON object that                     specifies one ordering. The position in the array identifies the rank of an ordering, i.e., whether                     it is primary, secondary, etc. The ordering objects have the following properties:                      **Note:** The `sorting` properties will not be applied to the External Task count query.
     * @type {Array<ExternalTaskQueryDtoSorting>}
     * @memberof ExternalTaskQueryDto
     */
    sorting?: Array<ExternalTaskQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface ExternalTaskQueryDtoSorting
 */
export interface ExternalTaskQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof ExternalTaskQueryDtoSorting
     */
    sortBy?: ExternalTaskQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof ExternalTaskQueryDtoSorting
     */
    sortOrder?: ExternalTaskQueryDtoSorting.SortOrderEnum;
}

/**
 * @export
 * @namespace ExternalTaskQueryDtoSorting
 */
export namespace ExternalTaskQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        Id = <any> 'id',
        LockExpirationTime = <any> 'lockExpirationTime',
        ProcessInstanceId = <any> 'processInstanceId',
        ProcessDefinitionId = <any> 'processDefinitionId',
        ProcessDefinitionKey = <any> 'processDefinitionKey',
        TaskPriority = <any> 'taskPriority',
        TenantId = <any> 'tenantId'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface FetchExternalTaskTopicDto
 */
export interface FetchExternalTaskTopicDto {
    /**
     * **Mandatory.** The topic's name.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    topicName: string;
    /**
     * **Mandatory.** The duration to lock the external tasks for in milliseconds.
     * @type {number}
     * @memberof FetchExternalTaskTopicDto
     */
    lockDuration: number;
    /**
     * A JSON array of `String` values that represent variable names. For each result task belonging to this topic, the given variables are returned as well if they are accessible from the external task's execution. If not provided - all variables will be fetched.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    variables?: Array<string>;
    /**
     * If `true` only local variables will be fetched.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    localVariables?: boolean;
    /**
     * A `String` value which enables the filtering of tasks based on process instance business key.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    businessKey?: string;
    /**
     * Filter tasks based on process definition id.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    processDefinitionId?: string;
    /**
     * Filter tasks based on process definition ids.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    processDefinitionIdIn?: Array<string>;
    /**
     * Filter tasks based on process definition key.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    processDefinitionKey?: string;
    /**
     * Filter tasks based on process definition keys.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    processDefinitionKeyIn?: Array<string>;
    /**
     * Filter tasks based on process definition version tag.
     * @type {string}
     * @memberof FetchExternalTaskTopicDto
     */
    processDefinitionVersionTag?: string;
    /**
     * Filter tasks without tenant id.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    withoutTenantId?: boolean;
    /**
     * Filter tasks based on tenant ids.
     * @type {Array<string>}
     * @memberof FetchExternalTaskTopicDto
     */
    tenantIdIn?: Array<string>;
    /**
     * A `JSON` object used for filtering tasks based on process instance variable values. A property name of the object represents a process variable name, while the property value represents the process variable value to filter tasks by.
     * @type {{ [key: string]: any; }}
     * @memberof FetchExternalTaskTopicDto
     */
    processVariables?: { [key: string]: any; };
    /**
     * Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default `false`).  If set to `true`, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson's](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API's classpath.  If set to `false`, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.
     * @type {boolean}
     * @memberof FetchExternalTaskTopicDto
     */
    deserializeValues?: boolean;
}
/**
 * 
 * @export
 * @interface FetchExternalTasksDto
 */
export interface FetchExternalTasksDto {
    /**
     * **Mandatory.** The id of the worker on which behalf tasks are fetched. The returned tasks are locked for that worker and can only be completed when providing the same worker id.
     * @type {string}
     * @memberof FetchExternalTasksDto
     */
    workerId: string;
    /**
     * **Mandatory.** The maximum number of tasks to return.
     * @type {number}
     * @memberof FetchExternalTasksDto
     */
    maxTasks: number;
    /**
     * A `boolean` value, which indicates whether the task should be fetched based on its priority or arbitrarily.
     * @type {boolean}
     * @memberof FetchExternalTasksDto
     */
    usePriority?: boolean;
    /**
     * The [Long Polling](https://docs.camunda.org/manual/7.13/user-guide/process-engine/external-tasks/#long-polling-to-fetch-and-lock-external-tasks) timeout in milliseconds.  **Note:** The value cannot be set larger than 1.800.000 milliseconds (corresponds to 30 minutes).
     * @type {number}
     * @memberof FetchExternalTasksDto
     */
    asyncResponseTimeout?: number;
    /**
     * A JSON array of topic objects for which external tasks should be fetched. The returned tasks may be arbitrarily distributed among these topics. Each topic object has the following properties:
     * @type {Array<FetchExternalTaskTopicDto>}
     * @memberof FetchExternalTasksDto
     */
    topics?: Array<FetchExternalTaskTopicDto>;
}
/**
 * 
 * @export
 * @interface FormDto
 */
export interface FormDto {
    /**
     * The form key.
     * @type {string}
     * @memberof FormDto
     */
    key?: string;
    /**
     * The context path of the process application. If the task (or the process definition) does not belong to a process application deployment or a process definition at all, this property is not set.
     * @type {string}
     * @memberof FormDto
     */
    contextPath?: string;
}
/**
 * A historic process instance query which defines a group of historic process instances
 * @export
 * @interface HistoricProcessInstanceQueryDto
 */
export interface HistoricProcessInstanceQueryDto {
    /**
     * Filter by process instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processInstanceId?: string;
    /**
     * Filter by process instance ids. Must be a JSON array process instance ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processInstanceIds?: Array<string>;
    /**
     * Filter by the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionId?: string;
    /**
     * Filter by the key of the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionKey?: string;
    /**
     * Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionKeyIn?: Array<string>;
    /**
     * Filter by the name of the process definition the instances run on.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionName?: string;
    /**
     * Filter by process definition names that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionNameLike?: string;
    /**
     * Exclude instances that belong to a set of process definitions. Must be a JSON array of process definition keys.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processDefinitionKeyNotIn?: Array<string>;
    /**
     * Filter by process instance business key.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processInstanceBusinessKey?: string;
    /**
     * Filter by process instance business key that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    processInstanceBusinessKeyLike?: string;
    /**
     * Restrict the query to all process instances that are top level process instances.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    rootProcessInstances?: boolean;
    /**
     * Only include finished process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    finished?: boolean;
    /**
     * Only include unfinished process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    unfinished?: boolean;
    /**
     * Only include process instances which have an incident. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    withIncidents?: boolean;
    /**
     * Only include process instances which have a root incident. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    withRootIncidents?: boolean;
    /**
     * Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types. 
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    incidentType?: string;
    /**
     * Only include process instances which have an incident in status either open or resolved. To get all process instances, use the query parameter withIncidents.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    incidentStatus?: HistoricProcessInstanceQueryDto.IncidentStatusEnum;
    /**
     * Filter by the incident message. Exact match.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    incidentMessage?: string;
    /**
     * Filter by the incident message that the parameter is a substring of.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    incidentMessageLike?: string;
    /**
     * Restrict to instances that were started before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    startedBefore?: Date;
    /**
     * Restrict to instances that were started after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    startedAfter?: Date;
    /**
     * Restrict to instances that were finished before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    finishedBefore?: Date;
    /**
     * Restrict to instances that were finished after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    finishedAfter?: Date;
    /**
     * Restrict to instances that executed an activity after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    executedActivityAfter?: Date;
    /**
     * Restrict to instances that executed an activity before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    executedActivityBefore?: Date;
    /**
     * Restrict to instances that executed an job after the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    executedJobAfter?: Date;
    /**
     * Restrict to instances that executed an job before the given date (inclusive). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof HistoricProcessInstanceQueryDto
     */
    executedJobBefore?: Date;
    /**
     * Only include process instances that were started by the given user.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    startedBy?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    superProcessInstanceId?: string;
    /**
     * Restrict query to one process instance that has a sub process instance with the given id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    subProcessInstanceId?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    superCaseInstanceId?: string;
    /**
     * Restrict query to one process instance that has a sub case instance with the given id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    subCaseInstanceId?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDto
     */
    caseInstanceId?: string;
    /**
     * Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    tenantIdIn?: Array<string>;
    /**
     * Only include historic process instances which belong to no tenant. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    withoutTenantId?: boolean;
    /**
     * Restrict to instances that executed an activity with one of given ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    executedActivityIdIn?: Array<string>;
    /**
     * Restrict to instances that have an active activity with one of given ids.
     * @type {Array<string>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    activeActivityIdIn?: Array<string>;
    /**
     * Restrict to instances that are active.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    active?: boolean;
    /**
     * Restrict to instances that are suspended.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    suspended?: boolean;
    /**
     * Restrict to instances that are completed.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    completed?: boolean;
    /**
     * Restrict to instances that are externallyTerminated.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    externallyTerminated?: boolean;
    /**
     * Restrict to instances that are internallyTerminated.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    internallyTerminated?: boolean;
    /**
     * A JSON array to only include process instances that have/had variables with certain values. The array consists of objects with the three properties `name`, `operator` and `value`. `name` (String) is the variable name, `operator` (String) is the comparison operator to be used and `value` the variable value. `value` may be String, Number or Boolean. Valid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    variables?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names provided in variables case-insensitively. If set to true variableName and variablename are treated as equal.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    variableNamesIgnoreCase?: boolean;
    /**
     * Match all variable values provided in variables case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @type {boolean}
     * @memberof HistoricProcessInstanceQueryDto
     */
    variableValuesIgnoreCase?: boolean;
    /**
     * A JSON array of nested historic process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query's predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: sorting See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<HistoricProcessInstanceQueryDto>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    orQueries?: Array<HistoricProcessInstanceQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<HistoricProcessInstanceQueryDtoSorting>}
     * @memberof HistoricProcessInstanceQueryDto
     */
    sorting?: Array<HistoricProcessInstanceQueryDtoSorting>;
}

/**
 * @export
 * @namespace HistoricProcessInstanceQueryDto
 */
export namespace HistoricProcessInstanceQueryDto {
    /**
     * @export
     * @enum {string}
     */
    export enum IncidentStatusEnum {
        Open = <any> 'open',
        Resolved = <any> 'resolved'
    }
}
/**
 * 
 * @export
 * @interface HistoricProcessInstanceQueryDtoSorting
 */
export interface HistoricProcessInstanceQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDtoSorting
     */
    sortBy?: HistoricProcessInstanceQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof HistoricProcessInstanceQueryDtoSorting
     */
    sortOrder?: HistoricProcessInstanceQueryDtoSorting.SortOrderEnum;
}

/**
 * @export
 * @namespace HistoricProcessInstanceQueryDtoSorting
 */
export namespace HistoricProcessInstanceQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        InstanceId = <any> 'instanceId',
        DefinitionId = <any> 'definitionId',
        DefinitionKey = <any> 'definitionKey',
        DefinitionName = <any> 'definitionName',
        DefinitionVersion = <any> 'definitionVersion',
        BusinessKey = <any> 'businessKey',
        StartTime = <any> 'startTime',
        EndTime = <any> 'endTime',
        Duration = <any> 'duration',
        TenantId = <any> 'tenantId'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface HistoryTimeToLiveDto
 */
export interface HistoryTimeToLiveDto {
    /**
     * New value for historyTimeToLive field of the definition. Can be `null`. Can not be negative.
     * @type {number}
     * @memberof HistoryTimeToLiveDto
     */
    historyTimeToLive?: number;
}
/**
 * 
 * @export
 * @interface IdentityLinkDto
 */
export interface IdentityLinkDto {
    /**
     * The id of the user participating in this link. Either `userId` or `groupId` is set.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    userId?: string;
    /**
     * The id of the group participating in this link. Either `groupId` or `userId` is set.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    groupId?: string;
    /**
     * The type of the identity link. The value of the this property can be user-defined. The Process Engine provides three pre-defined Identity Link `type`s:  * `candidate` * `assignee` - reserved for the task assignee * `owner` - reserved for the task owner  **Note**: When adding or removing an Identity Link, the `type` property must be defined.
     * @type {string}
     * @memberof IdentityLinkDto
     */
    type: string;
}
/**
 * 
 * @export
 * @interface IncidentStatisticsResultDto
 */
export interface IncidentStatisticsResultDto {
    /**
     * The type of the incident the number of incidents is aggregated for. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @type {string}
     * @memberof IncidentStatisticsResultDto
     */
    incidentType?: string;
    /**
     * The total number of incidents for the corresponding incident type.
     * @type {number}
     * @memberof IncidentStatisticsResultDto
     */
    incidentCount?: number;
}
/**
 * 
 * @export
 * @interface LinkableDto
 */
export interface LinkableDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof LinkableDto
     */
    links?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface LockedExternalTaskDto
 */
export interface LockedExternalTaskDto {
    /**
     * The id of the activity that this external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    activityId?: string;
    /**
     * The id of the activity instance that the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    activityInstanceId?: string;
    /**
     * The full error message submitted with the latest reported failure executing this task;`null` if no failure was reported previously or if no error message was submitted
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    errorMessage?: string;
    /**
     * The error details submitted with the latest reported failure executing this task.`null` if no failure was reported previously or if no error details was submitted
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    errorDetails?: string;
    /**
     * The id of the execution that the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    executionId?: string;
    /**
     * The id of the external task.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    id?: string;
    /**
     * The date that the task's most recent lock expires or has expired.
     * @type {Date}
     * @memberof LockedExternalTaskDto
     */
    lockExpirationTime?: Date;
    /**
     * The id of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    processDefinitionId?: string;
    /**
     * The key of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    processDefinitionKey?: string;
    /**
     * The version tag of the process definition the external task is defined in.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    processDefinitionVersionTag?: string;
    /**
     * The id of the process instance the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    processInstanceId?: string;
    /**
     * The id of the tenant the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    tenantId?: string;
    /**
     * The number of retries the task currently has left.
     * @type {number}
     * @memberof LockedExternalTaskDto
     */
    retries?: number;
    /**
     * Whether the process instance the external task belongs to is suspended.
     * @type {boolean}
     * @memberof LockedExternalTaskDto
     */
    suspended?: boolean;
    /**
     * The id of the worker that posesses or posessed the most recent lock.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    workerId?: string;
    /**
     * The priority of the external task.
     * @type {number}
     * @memberof LockedExternalTaskDto
     */
    priority?: number;
    /**
     * The topic name of the external task.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    topicName?: string;
    /**
     * The business key of the process instance the external task belongs to.
     * @type {string}
     * @memberof LockedExternalTaskDto
     */
    businessKey?: string;
    /**
     * A JSON object containing a property for each of the requested variables. The key is the variable name, the value is a JSON object of serialized variable values with the following properties:
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof LockedExternalTaskDto
     */
    variables?: { [key: string]: VariableValueDto; };
}
/**
 * The `processInstance` property only has a value if the resultType is set to `ProcessDefinition`. The processInstance with the properties as described in the [get single instance](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get/) method.  The `execution` property only has a value if the resultType is set to `Execution`. The execution with the properties as described in the [get single execution](https://docs.camunda.org/manual/7.13/reference/rest/execution/get/) method.
 * @export
 * @interface MessageCorrelationResultWithVariableDto
 */
export interface MessageCorrelationResultWithVariableDto {
    /**
     * Indicates if the message was correlated to a message start event or an  intermediate message catching event. In the first case, the resultType is  `ProcessDefinition` and otherwise `Execution`.
     * @type {string}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    resultType?: MessageCorrelationResultWithVariableDto.ResultTypeEnum;
    /**
     * 
     * @type {ProcessInstanceDto}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    processInstance?: ProcessInstanceDto;
    /**
     * 
     * @type {ExecutionDto}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    execution?: ExecutionDto;
    /**
     * This property is returned if the `variablesInResultEnabled` is set to `true`. Contains a list of the process variables. 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof MessageCorrelationResultWithVariableDto
     */
    variables?: { [key: string]: VariableValueDto; };
}

/**
 * @export
 * @namespace MessageCorrelationResultWithVariableDto
 */
export namespace MessageCorrelationResultWithVariableDto {
    /**
     * @export
     * @enum {string}
     */
    export enum ResultTypeEnum {
        Execution = <any> 'Execution',
        ProcessDefinition = <any> 'ProcessDefinition'
    }
}
/**
 * 
 * @export
 * @interface MetricsIntervalResultDto
 */
export interface MetricsIntervalResultDto {
    /**
     * The interval timestamp.
     * @type {Date}
     * @memberof MetricsIntervalResultDto
     */
    timestamp?: Date;
    /**
     * The name of the metric.
     * @type {string}
     * @memberof MetricsIntervalResultDto
     */
    name?: string;
    /**
     * The reporter of the metric. `null` if the metrics are aggregated by reporter.
     * @type {string}
     * @memberof MetricsIntervalResultDto
     */
    reporter?: string;
    /**
     * The value of the metric aggregated by the interval.
     * @type {number}
     * @memberof MetricsIntervalResultDto
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface MetricsResultDto
 */
export interface MetricsResultDto {
    /**
     * The current sum (count) for the selected metric.
     * @type {number}
     * @memberof MetricsResultDto
     */
    result?: number;
}
/**
 * 
 * @export
 * @interface MissingAuthorizationDto
 */
export interface MissingAuthorizationDto {
    /**
     * The permission name that the user is missing.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    permissionName?: string;
    /**
     * The name of the resource that the user is missing permission for.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    resourceName?: string;
    /**
     * The id of the resource that the user is missing permission for.
     * @type {string}
     * @memberof MissingAuthorizationDto
     */
    resourceId?: string;
}
/**
 * 
 * @export
 * @interface MultiFormAttachmentDto
 */
export interface MultiFormAttachmentDto {
    /**
     * The name of the attachment.
     * @type {string}
     * @memberof MultiFormAttachmentDto
     */
    attachmentName?: string;
    /**
     * The description of the attachment.
     * @type {string}
     * @memberof MultiFormAttachmentDto
     */
    attachmentDescription?: string;
    /**
     * The type of the attachment.
     * @type {string}
     * @memberof MultiFormAttachmentDto
     */
    attachmentType?: string;
    /**
     * The url to the remote content of the attachment.
     * @type {string}
     * @memberof MultiFormAttachmentDto
     */
    url?: string;
    /**
     * The content of the attachment.
     * @type {Blob}
     * @memberof MultiFormAttachmentDto
     */
    content?: Blob;
}
/**
 * 
 * @export
 * @interface MultiFormDeploymentDto
 */
export interface MultiFormDeploymentDto {
    /**
     * The tenant id for the deployment to be created.
     * @type {string}
     * @memberof MultiFormDeploymentDto
     */
    tenantId?: string;
    /**
     * The source for the deployment to be created.
     * @type {string}
     * @memberof MultiFormDeploymentDto
     */
    deploymentSource?: string;
    /**
     * A flag indicating whether the process engine should perform duplicate checking on a per-resource basis. If set to true, only those resources that have actually changed are deployed. Checks are made against resources included previous deployments of the same name and only against the latest versions of those resources. If set to true, the option enable-duplicate-filtering is overridden and set to true.
     * @type {boolean}
     * @memberof MultiFormDeploymentDto
     */
    deployChangedOnly?: boolean;
    /**
     * A flag indicating whether the process engine should perform duplicate checking for the deployment or not. This allows you to check if a deployment with the same name and the same resouces already exists and if true, not create a new deployment but instead return the existing deployment. The default value is false.
     * @type {boolean}
     * @memberof MultiFormDeploymentDto
     */
    enableDuplicateFiltering?: boolean;
    /**
     * The name for the deployment to be created.
     * @type {string}
     * @memberof MultiFormDeploymentDto
     */
    deploymentName?: string;
    /**
     * The binary data to create the deployment resource. It is possible to have more than one form part with different form part names for the binary data to create a deployment.
     * @type {Blob}
     * @memberof MultiFormDeploymentDto
     */
    data?: Blob;
}
/**
 * 
 * @export
 * @interface MultiFormVariableBinaryDto
 */
export interface MultiFormVariableBinaryDto {
    /**
     * The binary data to be set. For File variables, this multipart can contain the filename, binary value and MIME type of the file variable to be set Only the filename is mandatory.
     * @type {Blob}
     * @memberof MultiFormVariableBinaryDto
     */
    data?: Blob;
    /**
     * The name of the variable type. Either Bytes for a byte array variable or File for a file variable.
     * @type {string}
     * @memberof MultiFormVariableBinaryDto
     */
    valueType?: MultiFormVariableBinaryDto.ValueTypeEnum;
}

/**
 * @export
 * @namespace MultiFormVariableBinaryDto
 */
export namespace MultiFormVariableBinaryDto {
    /**
     * @export
     * @enum {string}
     */
    export enum ValueTypeEnum {
        Bytes = <any> 'Bytes',
        File = <any> 'File'
    }
}
/**
 * 
 * @export
 * @interface ParseExceptionDto
 */
export interface ParseExceptionDto {
    /**
     * An exception class indicating the occurred error.
     * @type {string}
     * @memberof ParseExceptionDto
     */
    type?: string;
    /**
     * A detailed message of the error.
     * @type {string}
     * @memberof ParseExceptionDto
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface PatchVariablesDto
 */
export interface PatchVariablesDto {
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof PatchVariablesDto
     */
    modifications?: { [key: string]: VariableValueDto; };
    /**
     * An array of String keys of variables to be deleted.
     * @type {Array<string>}
     * @memberof PatchVariablesDto
     */
    deletions?: Array<string>;
}
/**
 * 
 * @export
 * @interface PriorityDto
 */
export interface PriorityDto {
    /**
     * The priority of the resource.
     * @type {number}
     * @memberof PriorityDto
     */
    priority?: number;
}
/**
 * 
 * @export
 * @interface ProblemDto
 */
export interface ProblemDto {
    /**
     * The message of the problem.
     * @type {string}
     * @memberof ProblemDto
     */
    message?: string;
    /**
     * The line where the problem occurred.
     * @type {number}
     * @memberof ProblemDto
     */
    line?: number;
    /**
     * The column where the problem occurred.
     * @type {number}
     * @memberof ProblemDto
     */
    column?: number;
    /**
     * The main element id where the problem occurred.
     * @type {string}
     * @memberof ProblemDto
     */
    mainElementId?: string;
    /**
     * A list of element id affected by the problem.
     * @type {Array<string>}
     * @memberof ProblemDto
     */
    elementIds?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionDiagramDto
 */
export interface ProcessDefinitionDiagramDto {
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDiagramDto
     */
    id?: string;
    /**
     * An escaped XML string containing the XML that this definition was deployed with. Carriage returns, line feeds and quotation marks are escaped.
     * @type {string}
     * @memberof ProcessDefinitionDiagramDto
     */
    bpmn20Xml?: string;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionDto
 */
export interface ProcessDefinitionDto {
    /**
     * The id of the process definition
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    id?: string;
    /**
     * The key of the process definition, i.e., the id of the BPMN 2.0 XML process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    key?: string;
    /**
     * The category of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    category?: string;
    /**
     * The description of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    description?: string;
    /**
     * The name of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    name?: string;
    /**
     * The version of the process definition that the engine assigned to it.
     * @type {number}
     * @memberof ProcessDefinitionDto
     */
    version?: number;
    /**
     * The file name of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    resource?: string;
    /**
     * The deployment id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    deploymentId?: string;
    /**
     * The file name of the process definition diagram, if it exists.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    diagram?: string;
    /**
     * A flag indicating whether the definition is suspended or not.
     * @type {boolean}
     * @memberof ProcessDefinitionDto
     */
    suspended?: boolean;
    /**
     * The tenant id of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    tenantId?: string;
    /**
     * The version tag of the process definition.
     * @type {string}
     * @memberof ProcessDefinitionDto
     */
    versionTag?: string;
    /**
     * History time to live value of the process definition. Is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @type {number}
     * @memberof ProcessDefinitionDto
     */
    historyTimeToLive?: number;
    /**
     * A flag indicating whether the process definition is startable in Tasklist or not.
     * @type {boolean}
     * @memberof ProcessDefinitionDto
     */
    startableInTasklist?: boolean;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionStatisticsResultDto
 */
export interface ProcessDefinitionStatisticsResultDto {
    /**
     * The id of the process definition the results are aggregated for.
     * @type {string}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    id?: string;
    /**
     * The total number of running process instances of this process definition.
     * @type {number}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    instances?: number;
    /**
     * The total number of failed jobs for the running instances. **Note**: Will be `0` (not `null`), if failed jobs were excluded.
     * @type {number}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    failedJobs?: number;
    /**
     * Each item in the resulting array is an object which contains `incidentType` and `incidentCount`. **Note**: Will be an empty array, if `incidents` or `incidentsForType` were excluded. Furthermore, the array will be also empty if no incidents were found.
     * @type {Array<IncidentStatisticsResultDto>}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    incidents?: Array<IncidentStatisticsResultDto>;
    /**
     * 
     * @type {ProcessDefinitionDto}
     * @memberof ProcessDefinitionStatisticsResultDto
     */
    definition?: ProcessDefinitionDto;
}
/**
 * 
 * @export
 * @interface ProcessDefinitionSuspensionStateDto
 */
export interface ProcessDefinitionSuspensionStateDto {
    /**
     * A `Boolean` value which indicates whether to activate or suspend all process definitions with the given key. When the value is set to `true`, all process definitions with the given key will be suspended and when the value is set to `false`, all process definitions with the given key will be activated.
     * @type {boolean}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    suspended?: boolean;
    /**
     * The id of the process definitions to activate or suspend.
     * @type {string}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    processDefinitionId?: string;
    /**
     *  The key of the process definitions to activate or suspend.
     * @type {string}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    processDefinitionKey?: string;
    /**
     * A `Boolean` value which indicates whether to activate or suspend also all process instances of  the process definitions with the given key. When the value is set to `true`, all process instances of the process definitions with the given key will be activated or suspended and when the value is set to `false`, the suspension state of  all process instances of the process definitions with the given key will not be updated.
     * @type {boolean}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    includeProcessInstances?: boolean;
    /**
     * The date on which all process definitions with the given key will be activated or suspended. If `null`, the suspension state of all process definitions with the given key is updated immediately. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format yyyy-MM-dd'T'HH:mm:ss.SSSZ, e.g., 2013-01-23T14:42:45.000+0200.
     * @type {Date}
     * @memberof ProcessDefinitionSuspensionStateDto
     */
    executionDate?: Date;
}
/**
 * 
 * @export
 * @interface ProcessEngineDto
 */
export interface ProcessEngineDto {
    /**
     * The name of the process engine.
     * @type {string}
     * @memberof ProcessEngineDto
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceDto
 */
export interface ProcessInstanceDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof ProcessInstanceDto
     */
    links?: Array<AtomLink>;
}
/**
 * 
 * @export
 * @interface ProcessInstanceModificationDto
 */
export interface ProcessInstanceModificationDto {
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof ProcessInstanceModificationDto
     */
    skipCustomListeners?: boolean;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started or ended as part of this request.
     * @type {boolean}
     * @memberof ProcessInstanceModificationDto
     */
    skipIoMappings?: boolean;
    /**
     * JSON array of modification instructions. The instructions are executed in the order they are in.
     * @type {Array<ProcessInstanceModificationInstructionDto>}
     * @memberof ProcessInstanceModificationDto
     */
    instructions?: Array<ProcessInstanceModificationInstructionDto>;
    /**
     * An arbitrary text annotation set by a user for auditing reasons.
     * @type {string}
     * @memberof ProcessInstanceModificationDto
     */
    annotation?: string;
}
/**
 * 
 * @export
 * @interface ProcessInstanceModificationInstructionDto
 */
export interface ProcessInstanceModificationInstructionDto {
    /**
     * **Mandatory**. One of the following values: `cancel`, `startBeforeActivity`, `startAfterActivity`, `startTransition`.  * A cancel instruction requests cancellation of a single activity instance or all instances of one activity. * A startBeforeActivity instruction requests to enter a given activity. * A startAfterActivity instruction requests to execute the single outgoing sequence flow of a given activity. * A startTransition instruction requests to execute a specific sequence flow.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    type: ProcessInstanceModificationInstructionDto.TypeEnum;
    /**
     * 
     * @type {TriggerVariableValueDto}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    variables?: TriggerVariableValueDto;
    /**
     * Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    activityId?: string;
    /**
     * Can be used with instructions of types `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    transitionId?: string;
    /**
     * Can be used with instructions of type `cancel`. Specifies the activity instance to cancel. Valid values are the activity instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    activityInstanceId?: string;
    /**
     * Can be used with instructions of type `cancel`. Specifies the transition instance to cancel. Valid values are the transition instance IDs supplied by the [Get Activity Instance request](https://docs.camunda.org/manual/7.13/reference/rest/process-instance/get-activity-instances/).
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    transitionInstanceId?: string;
    /**
     * Can be used with instructions of type `startBeforeActivity`, `startAfterActivity`, and `startTransition`. Valid values are the activity instance IDs supplied by the Get Activity Instance request. If there are multiple parent activity instances of the targeted activity, this specifies the ancestor scope in which hierarchy the activity/transition is to be instantiated.  Example: When there are two instances of a subprocess and an activity contained in the subprocess is to be started, this parameter allows to specifiy under which subprocess instance the activity should be started.
     * @type {string}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    ancestorActivityInstanceId?: string;
    /**
     * Can be used with instructions of type cancel. Prevents the deletion of new created activity instances.
     * @type {boolean}
     * @memberof ProcessInstanceModificationInstructionDto
     */
    cancelCurrentActiveActivityInstances?: boolean;
}

/**
 * @export
 * @namespace ProcessInstanceModificationInstructionDto
 */
export namespace ProcessInstanceModificationInstructionDto {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        Cancel = <any> 'cancel',
        StartBeforeActivity = <any> 'startBeforeActivity',
        StartAfterActivity = <any> 'startAfterActivity',
        StartTransition = <any> 'startTransition'
    }
}
/**
 * A process instance query which defines a group of process instances
 * @export
 * @interface ProcessInstanceQueryDto
 */
export interface ProcessInstanceQueryDto {
    /**
     * Filter by the deployment the id belongs to.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    deploymentId?: string;
    /**
     * Filter by the process definition the instances run on.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    processDefinitionId?: string;
    /**
     * Filter by the key of the process definition the instances run on.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    processDefinitionKey?: string;
    /**
     * Filter by a list of process definition keys. A process instance must have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    processDefinitionKeyIn?: Array<string>;
    /**
     * Exclude instances by a list of process definition keys. A process instance must not have one of the given process definition keys. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    processDefinitionKeyNotIn?: Array<string>;
    /**
     * Filter by process instance business key.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    businessKey?: string;
    /**
     * Filter by process instance business key that the parameter is a substring of.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    businessKeyLike?: string;
    /**
     * Filter by case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    caseInstanceId?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    superProcessInstance?: string;
    /**
     * Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    subProcessInstance?: string;
    /**
     * Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    superCaseInstance?: string;
    /**
     * Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    subCaseInstance?: string;
    /**
     * Only include active process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    active?: boolean;
    /**
     * Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    suspended?: boolean;
    /**
     * Filter by a list of process instance ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    processInstanceIds?: Array<string>;
    /**
     * Filter by presence of incidents. Selects only process instances that have an incident.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    withIncident?: boolean;
    /**
     * Filter by the incident id.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    incidentId?: string;
    /**
     * Filter by the incident type. See the User Guide for a list of incident types.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    incidentType?: string;
    /**
     * Filter by the incident message. Exact match.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    incidentMessage?: string;
    /**
     * Filter by the incident message that the parameter is a substring of.
     * @type {string}
     * @memberof ProcessInstanceQueryDto
     */
    incidentMessageLike?: string;
    /**
     * Filter by a list of tenant ids. A process instance must have one of the given tenant ids. Must be a JSON array of Strings.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    tenantIdIn?: Array<string>;
    /**
     * Only include process instances which belong to no tenant. Value may only be true, as false is the default behavior.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    withoutTenantId?: boolean;
    /**
     * Only include process instances which process definition has no tenant id.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    processDefinitionWithoutTenantId?: boolean;
    /**
     * Filter by a list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @type {Array<string>}
     * @memberof ProcessInstanceQueryDto
     */
    activityIdIn?: Array<string>;
    /**
     * Restrict the query to all process instances that are top level process instances.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    rootProcessInstances?: boolean;
    /**
     * Restrict the query to all process instances that are leaf instances. (i.e. don't have any sub instances)
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    leafProcessInstances?: boolean;
    /**
     * A JSON array to only include process instances that have variables with certain values. The array consists of objects with the three properties `name`, `operator` and `value`. `name` (String) is the variable name, `operator` (String) is the comparison operator to be used and `value` the variable value. The `value` may be String, Number or Boolean.  Valid operator values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof ProcessInstanceQueryDto
     */
    variables?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    variableNamesIgnoreCase?: boolean;
    /**
     * Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @type {boolean}
     * @memberof ProcessInstanceQueryDto
     */
    variableValuesIgnoreCase?: boolean;
    /**
     * A JSON array of nested process instance queries with OR semantics. A process instance matches a nested query if it fulfills at least one of the query's predicates. With multiple nested queries, a process instance must fulfill at least one predicate of each query (Conjunctive Normal Form). All process instance query properties can be used except for: `sorting` See the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<ProcessInstanceQueryDto>}
     * @memberof ProcessInstanceQueryDto
     */
    orQueries?: Array<ProcessInstanceQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<ProcessInstanceQueryDtoSorting>}
     * @memberof ProcessInstanceQueryDto
     */
    sorting?: Array<ProcessInstanceQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface ProcessInstanceQueryDtoSorting
 */
export interface ProcessInstanceQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof ProcessInstanceQueryDtoSorting
     */
    sortBy?: ProcessInstanceQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof ProcessInstanceQueryDtoSorting
     */
    sortOrder?: ProcessInstanceQueryDtoSorting.SortOrderEnum;
}

/**
 * @export
 * @namespace ProcessInstanceQueryDtoSorting
 */
export namespace ProcessInstanceQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        InstanceId = <any> 'instanceId',
        DefinitionId = <any> 'definitionId',
        DefinitionKey = <any> 'definitionKey',
        BusinessKey = <any> 'businessKey',
        TenantId = <any> 'tenantId'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface ProcessInstanceSuspensionStateAsyncDto
 */
export interface ProcessInstanceSuspensionStateAsyncDto {
    /**
     * A Boolean value which indicates whether to activate or suspend a given process instance. When the value is set to true, the given process instance will be suspended and when the value is set to false, the given process instance will be activated.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    suspended?: boolean;
    /**
     * A list of process instance ids which defines a group of process instances which will be activated or suspended by the operation.
     * @type {Array<string>}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    processInstanceIds?: Array<string>;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    processInstanceQuery?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateAsyncDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface ProcessInstanceSuspensionStateDto
 */
export interface ProcessInstanceSuspensionStateDto {
    /**
     * A `Boolean` value which indicates whether to activate or suspend a given process instance. When the value is set to `true`, the given process instance will be suspended and when the value is set to `false`, the given process instance will be activated.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    suspended?: boolean;
    /**
     * The process definition id of the process instances to activate or suspend.  **Note**: This parameter can be used only with combination of `suspended`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processDefinitionId?: string;
    /**
     * The process definition key of the process instances to activate or suspend.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionTenantId`, and `processDefinitionWithoutTenantId`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processDefinitionKey?: string;
    /**
     * Only activate or suspend process instances of a process definition which belongs to a tenant with the given id.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionWithoutTenantId`.
     * @type {string}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processDefinitionTenantId?: string;
    /**
     * Only activate or suspend process instances of a process definition which belongs to no tenant. Value may only be true, as false is the default behavior.  **Note**: This parameter can be used only with combination of `suspended`, `processDefinitionKey`, and `processDefinitionTenantId`.
     * @type {boolean}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processDefinitionWithoutTenantId?: boolean;
    /**
     * A list of process instance ids which defines a group of process instances which will be activated or suspended by the operation.  **Note**: This parameter can be used only with combination of `suspended`, `processInstanceQuery`, and `historicProcessInstanceQuery`.
     * @type {Array<string>}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processInstanceIds?: Array<string>;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    processInstanceQuery?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof ProcessInstanceSuspensionStateDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface ProcessInstanceWithVariablesDto
 */
export interface ProcessInstanceWithVariablesDto {
    /**
     * The links associated to this resource, with `method`, `href` and `rel`.
     * @type {Array<AtomLink>}
     * @memberof ProcessInstanceWithVariablesDto
     */
    links?: Array<AtomLink>;
}
/**
 * A JSON object with the following properties:
 * @export
 * @interface RedeploymentDto
 */
export interface RedeploymentDto {
    /**
     * A list of deployment resource ids to re-deploy.
     * @type {Array<string>}
     * @memberof RedeploymentDto
     */
    resourceIds?: Array<string>;
    /**
     * A list of deployment resource names to re-deploy.
     * @type {Array<string>}
     * @memberof RedeploymentDto
     */
    resourceNames?: Array<string>;
    /**
     * Sets the source of the deployment.
     * @type {string}
     * @memberof RedeploymentDto
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface ResourceReportDto
 */
export interface ResourceReportDto {
    /**
     * A list of errors occurred during parsing.
     * @type {Array<ProblemDto>}
     * @memberof ResourceReportDto
     */
    errors?: Array<ProblemDto>;
    /**
     * A list of warnings occurred during parsing.
     * @type {Array<ProblemDto>}
     * @memberof ResourceReportDto
     */
    warnings?: Array<ProblemDto>;
}
/**
 * 
 * @export
 * @interface RestartProcessInstanceDto
 */
export interface RestartProcessInstanceDto {
    /**
     * A list of process instance ids to restart.
     * @type {Array<string>}
     * @memberof RestartProcessInstanceDto
     */
    processInstanceIds?: Array<string>;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof RestartProcessInstanceDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
    /**
     * Skip execution listener invocation for activities that are started as part of this request.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    skipCustomListeners?: boolean;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started as part of this request.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    skipIoMappings?: boolean;
    /**
     * Set the initial set of variables during restart. By default, the last set of variables is used.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    initialVariables?: boolean;
    /**
     * Do not take over the business key of the historic process instance.
     * @type {boolean}
     * @memberof RestartProcessInstanceDto
     */
    withoutBusinessKey?: boolean;
    /**
     * **Optional**. A JSON array of instructions that specify which activities to start the process instance at. If this property is omitted, the process instance starts at its default blank start event.
     * @type {Array<RestartProcessInstanceModificationInstructionDto>}
     * @memberof RestartProcessInstanceDto
     */
    instructions?: Array<RestartProcessInstanceModificationInstructionDto>;
}
/**
 * 
 * @export
 * @interface RestartProcessInstanceModificationInstructionDto
 */
export interface RestartProcessInstanceModificationInstructionDto {
    /**
     * **Mandatory**. One of the following values: `startBeforeActivity`, `startAfterActivity`, `startTransition`.  * A `startBeforeActivity` instruction requests to enter a given activity. * A `startAfterActivity` instruction requests to execute the single outgoing sequence flow of a given activity. * A `startTransition` instruction requests to execute a specific sequence flow.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    type: RestartProcessInstanceModificationInstructionDto.TypeEnum;
    /**
     * **Can be used with instructions of types** `startBeforeActivity` and `startAfterActivity`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    activityId?: string;
    /**
     * **Can be used with instructions of types** `startTransition`. Specifies the sequence flow to start.
     * @type {string}
     * @memberof RestartProcessInstanceModificationInstructionDto
     */
    transitionId?: string;
}

/**
 * @export
 * @namespace RestartProcessInstanceModificationInstructionDto
 */
export namespace RestartProcessInstanceModificationInstructionDto {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        StartBeforeActivity = <any> 'startBeforeActivity',
        StartAfterActivity = <any> 'startAfterActivity',
        StartTransition = <any> 'startTransition'
    }
}
/**
 * 
 * @export
 * @interface RetriesDto
 */
export interface RetriesDto {
    /**
     * The number of retries to set for the resource.  Must be >= 0. If this is 0, an incident is created and the task, or job, cannot be fetched, or acquired anymore unless the retries are increased again. Can not be null.
     * @type {number}
     * @memberof RetriesDto
     */
    retries?: number;
}
/**
 * 
 * @export
 * @interface SchemaLogEntryDto
 */
export interface SchemaLogEntryDto {
    /**
     * The id of the schema log entry.
     * @type {string}
     * @memberof SchemaLogEntryDto
     */
    id?: string;
    /**
     * The date and time of the schema update.
     * @type {Date}
     * @memberof SchemaLogEntryDto
     */
    timestamp?: Date;
    /**
     * The version of the schema.
     * @type {string}
     * @memberof SchemaLogEntryDto
     */
    version?: string;
}
/**
 * 
 * @export
 * @interface SchemaLogQueryDto
 */
export interface SchemaLogQueryDto {
    /**
     * The version of the schema.
     * @type {string}
     * @memberof SchemaLogQueryDto
     */
    version?: string;
    /**
     * A JSON array of criteria to sort the result by. Each element of the array is                       a JSON object that specifies one ordering. The position in the array                       identifies the rank of an ordering, i.e., whether it is primary, secondary,                       etc. 
     * @type {Array<SchemaLogQueryDtoSorting>}
     * @memberof SchemaLogQueryDto
     */
    sorting?: Array<SchemaLogQueryDtoSorting>;
}
/**
 * 
 * @export
 * @interface SchemaLogQueryDtoSorting
 */
export interface SchemaLogQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof SchemaLogQueryDtoSorting
     */
    sortBy?: SchemaLogQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof SchemaLogQueryDtoSorting
     */
    sortOrder?: SchemaLogQueryDtoSorting.SortOrderEnum;
}

/**
 * @export
 * @namespace SchemaLogQueryDtoSorting
 */
export namespace SchemaLogQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        Timestamp = <any> 'timestamp'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * 
 * @export
 * @interface SetJobRetriesByProcessDto
 */
export interface SetJobRetriesByProcessDto {
    /**
     * A list of process instance ids to fetch jobs, for which retries will be set.
     * @type {Array<string>}
     * @memberof SetJobRetriesByProcessDto
     */
    processInstances?: Array<string>;
    /**
     * An integer representing the number of retries. Please note that the value cannot be negative or null.
     * @type {number}
     * @memberof SetJobRetriesByProcessDto
     */
    retries?: number;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof SetJobRetriesByProcessDto
     */
    processInstanceQuery?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof SetJobRetriesByProcessDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface SetRetriesForExternalTasksDto
 */
export interface SetRetriesForExternalTasksDto {
    /**
     * The number of retries to set for the external task.  Must be >= 0. If this is 0, an incident is created and the task cannot be fetched anymore unless the retries are increased again. Can not be null.
     * @type {number}
     * @memberof SetRetriesForExternalTasksDto
     */
    retries?: number;
    /**
     * The ids of the external tasks to set the number of retries for.
     * @type {Array<string>}
     * @memberof SetRetriesForExternalTasksDto
     */
    externalTaskIds?: Array<string>;
    /**
     * The ids of process instances containing the tasks to set the number of retries for.
     * @type {Array<string>}
     * @memberof SetRetriesForExternalTasksDto
     */
    processInstanceIds?: Array<string>;
    /**
     * 
     * @type {ExternalTaskQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    externalTaskQuery?: ExternalTaskQueryDto;
    /**
     * 
     * @type {ProcessInstanceQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    processInstanceQuery?: ProcessInstanceQueryDto;
    /**
     * 
     * @type {HistoricProcessInstanceQueryDto}
     * @memberof SetRetriesForExternalTasksDto
     */
    historicProcessInstanceQuery?: HistoricProcessInstanceQueryDto;
}
/**
 * 
 * @export
 * @interface SignalDto
 */
export interface SignalDto {
    /**
     * The name of the signal to deliver.  **Note**: This property is mandatory.
     * @type {string}
     * @memberof SignalDto
     */
    name?: string;
    /**
     * Optionally specifies a single execution which is notified by the signal.  **Note**: If no execution id is defined the signal is broadcasted to all subscribed handlers. 
     * @type {string}
     * @memberof SignalDto
     */
    executionId?: string;
    /**
     * A JSON object containing variable key-value pairs. Each key is a variable name and each value a JSON variable value object.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof SignalDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * Specifies a tenant to deliver the signal. The signal can only be received on executions or process definitions which belongs to the given tenant.  **Note**: Cannot be used in combination with executionId.
     * @type {string}
     * @memberof SignalDto
     */
    tenantId?: string;
    /**
     * If true the signal can only be received on executions or process definitions which belongs to no tenant. Value may not be false as this is the default behavior.  **Note**: Cannot be used in combination with `executionId`.
     * @type {boolean}
     * @memberof SignalDto
     */
    withoutTenantId?: boolean;
}
/**
 * Mandatory when `sortBy` is one of the following values: `processVariable`, `executionVariable`, `taskVariable`, `caseExecutionVariable` or `caseInstanceVariable`. Must be a JSON object with the properties `variable` and `type` where `variable` is a variable name and `type` is the name of a variable value type.
 * @export
 * @interface SortTaskQueryParametersDto
 */
export interface SortTaskQueryParametersDto {
    /**
     * The name of the variable to sort by.
     * @type {string}
     * @memberof SortTaskQueryParametersDto
     */
    variable?: string;
    /**
     * The name of the type of the variable value.
     * @type {string}
     * @memberof SortTaskQueryParametersDto
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface StartProcessInstanceDto
 */
export interface StartProcessInstanceDto {
    /**
     * The business key of the process instance.
     * @type {string}
     * @memberof StartProcessInstanceDto
     */
    businessKey?: string;
    /**
     * 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof StartProcessInstanceDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * The case instance id the process instance is to be initialized with.
     * @type {string}
     * @memberof StartProcessInstanceDto
     */
    caseInstanceId?: string;
    /**
     * **Optional**. A JSON array of instructions that specify which activities to start the process instance at. If this property is omitted, the process instance starts at its default blank start event.
     * @type {Array<ProcessInstanceModificationInstructionDto>}
     * @memberof StartProcessInstanceDto
     */
    startInstructions?: Array<ProcessInstanceModificationInstructionDto>;
    /**
     * Skip execution listener invocation for activities that are started or ended as part of this request. **Note**: This option is currently only respected when start instructions are submitted via the `startInstructions` property.
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    skipCustomListeners?: boolean;
    /**
     * Skip execution of [input/output variable mappings](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/#input-output-variable-mapping) for activities that are started or ended as part of this request. **Note**: This option is currently only respected when start instructions are submitted via the `startInstructions` property.
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    skipIoMappings?: boolean;
    /**
     * Indicates if the variables, which was used by the process instance during execution, should be returned. Default value: `false`
     * @type {boolean}
     * @memberof StartProcessInstanceDto
     */
    withVariablesInReturn?: boolean;
}
/**
 * 
 * @export
 * @interface StartProcessInstanceFormDto
 */
export interface StartProcessInstanceFormDto {
    /**
     * 
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof StartProcessInstanceFormDto
     */
    variables?: { [key: string]: VariableValueDto; };
    /**
     * The business key the process instance is to be initialized with. The business key uniquely identifies the process instance in the context of the given process definition.
     * @type {string}
     * @memberof StartProcessInstanceFormDto
     */
    businessKey?: string;
}
/**
 * 
 * @export
 * @interface SuspensionStateDto
 */
export interface SuspensionStateDto {
    /**
     * A Boolean value which indicates whether to activate or suspend a given process instance. When the value is set to true, the given process instance will be suspended and when the value is set to false, the given process instance will be activated.
     * @type {boolean}
     * @memberof SuspensionStateDto
     */
    suspended?: boolean;
}
/**
 * 
 * @export
 * @interface TaskBpmnErrorDto
 */
export interface TaskBpmnErrorDto {
    /**
     * An error code that indicates the predefined error. It is used to identify the BPMN error handler.
     * @type {string}
     * @memberof TaskBpmnErrorDto
     */
    errorCode?: string;
    /**
     * An error message that describes the error.
     * @type {string}
     * @memberof TaskBpmnErrorDto
     */
    errorMessage?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof TaskBpmnErrorDto
     */
    variables?: { [key: string]: VariableValueDto; };
}
/**
 * 
 * @export
 * @interface TaskDto
 */
export interface TaskDto {
    /**
     * The task id.
     * @type {string}
     * @memberof TaskDto
     */
    id?: string;
    /**
     * The task name.
     * @type {string}
     * @memberof TaskDto
     */
    name?: string;
    /**
     * The assignee's id.
     * @type {string}
     * @memberof TaskDto
     */
    assignee?: string;
    /**
     * The owner's id.
     * @type {string}
     * @memberof TaskDto
     */
    owner?: string;
    /**
     * The date the task was created on. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
     * @type {Date}
     * @memberof TaskDto
     */
    created?: Date;
    /**
     * The task's due date. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
     * @type {Date}
     * @memberof TaskDto
     */
    due?: Date;
    /**
     * The follow-up date for the task. [Default format](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/) `yyyy-MM-dd'T'HH:mm:ss.SSSZ`.
     * @type {Date}
     * @memberof TaskDto
     */
    followUp?: Date;
    /**
     * The task's delegation state. Possible values are `PENDING` and `RESOLVED`.
     * @type {string}
     * @memberof TaskDto
     */
    delegationState?: TaskDto.DelegationStateEnum;
    /**
     * The task's description.
     * @type {string}
     * @memberof TaskDto
     */
    description?: string;
    /**
     * The id of the execution the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    executionId?: string;
    /**
     * The id the parent task, if this task is a subtask.
     * @type {string}
     * @memberof TaskDto
     */
    parentTaskId?: string;
    /**
     * The task's priority.
     * @type {number}
     * @memberof TaskDto
     */
    priority?: number;
    /**
     * The id of the process definition the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    processDefinitionId?: string;
    /**
     * The id of the process instance the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    processInstanceId?: string;
    /**
     * The id of the case execution the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    caseExecutionId?: string;
    /**
     * The id of the case definition the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    caseDefinitionId?: string;
    /**
     * The id of the case instance the task belongs to.
     * @type {string}
     * @memberof TaskDto
     */
    caseInstanceId?: string;
    /**
     * The task's key.
     * @type {string}
     * @memberof TaskDto
     */
    taskDefinitionKey?: string;
    /**
     * Whether the task belongs to a process instance that is suspended.
     * @type {boolean}
     * @memberof TaskDto
     */
    suspended?: boolean;
    /**
     * If not `null`, the form key for the task.
     * @type {string}
     * @memberof TaskDto
     */
    formKey?: string;
    /**
     * If not `null`, the tenant id of the task.
     * @type {string}
     * @memberof TaskDto
     */
    tenantId?: string;
}

/**
 * @export
 * @namespace TaskDto
 */
export namespace TaskDto {
    /**
     * @export
     * @enum {string}
     */
    export enum DelegationStateEnum {
        PENDING = <any> 'PENDING',
        RESOLVED = <any> 'RESOLVED'
    }
}
/**
 * 
 * @export
 * @interface TaskEscalationDto
 */
export interface TaskEscalationDto {
    /**
     * An escalation code that indicates the predefined escalation. It is used to identify the BPMN escalation handler.
     * @type {string}
     * @memberof TaskEscalationDto
     */
    escalationCode?: string;
    /**
     * A JSON object containing variable key-value pairs.
     * @type {{ [key: string]: VariableValueDto; }}
     * @memberof TaskEscalationDto
     */
    variables?: { [key: string]: VariableValueDto; };
}
/**
 * A Task query which defines a group of Tasks.
 * @export
 * @interface TaskQueryDto
 */
export interface TaskQueryDto {
    /**
     * Restrict to tasks that belong to process instances with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processInstanceId?: string;
    /**
     * Restrict to tasks that belong to process instances with the given ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    processInstanceIdIn?: Array<string>;
    /**
     * Restrict to tasks that belong to process instances with the given business key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processInstanceBusinessKey?: string;
    /**
     * Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processInstanceBusinessKeyExpression?: string;
    /**
     * Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    processInstanceBusinessKeyIn?: Array<string>;
    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processInstanceBusinessKeyLike?: string;
    /**
     * Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processInstanceBusinessKeyLikeExpression?: string;
    /**
     * Restrict to tasks that belong to a process definition with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processDefinitionId?: string;
    /**
     * Restrict to tasks that belong to a process definition with the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processDefinitionKey?: string;
    /**
     * Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    processDefinitionKeyIn?: Array<string>;
    /**
     * Restrict to tasks that belong to a process definition with the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processDefinitionName?: string;
    /**
     * Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    processDefinitionNameLike?: string;
    /**
     * Restrict to tasks that belong to an execution with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    executionId?: string;
    /**
     * Restrict to tasks that belong to case instances with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseInstanceId?: string;
    /**
     * Restrict to tasks that belong to case instances with the given business key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseInstanceBusinessKey?: string;
    /**
     * Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseInstanceBusinessKeyLike?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseDefinitionId?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseDefinitionKey?: string;
    /**
     * Restrict to tasks that belong to a case definition with the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseDefinitionName?: string;
    /**
     * Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseDefinitionNameLike?: string;
    /**
     * Restrict to tasks that belong to a case execution with the given id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    caseExecutionId?: string;
    /**
     * Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    activityInstanceIdIn?: Array<string>;
    /**
     * Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    tenantIdIn?: Array<string>;
    /**
     * Only include tasks which belong to no tenant. Value may only be `true`,  as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    withoutTenantId?: boolean;
    /**
     * Restrict to tasks that the given user is assigned to.
     * @type {string}
     * @memberof TaskQueryDto
     */
    assignee?: string;
    /**
     * Restrict to tasks that the user described by the given expression is assigned to. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    assigneeExpression?: string;
    /**
     * Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    assigneeLike?: string;
    /**
     * Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    assigneeLikeExpression?: string;
    /**
     * Only include tasks which are assigned to one of the passed and comma-separated user ids.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    assigneeIn?: Array<string>;
    /**
     * Restrict to tasks that the given user owns.
     * @type {string}
     * @memberof TaskQueryDto
     */
    owner?: string;
    /**
     * Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    ownerExpression?: string;
    /**
     * Only include tasks that are offered to the given group.
     * @type {string}
     * @memberof TaskQueryDto
     */
    candidateGroup?: string;
    /**
     * Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    candidateGroupExpression?: string;
    /**
     * Only include tasks that are offered to the given user or to one of his groups.
     * @type {string}
     * @memberof TaskQueryDto
     */
    candidateUser?: string;
    /**
     * Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    candidateUserExpression?: string;
    /**
     * Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    includeAssignedTasks?: boolean;
    /**
     * Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @type {string}
     * @memberof TaskQueryDto
     */
    involvedUser?: string;
    /**
     * Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @type {string}
     * @memberof TaskQueryDto
     */
    involvedUserExpression?: string;
    /**
     * If set to `true`, restricts the query to all tasks that are assigned.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    assigned?: boolean;
    /**
     * If set to `true`, restricts the query to all tasks that are unassigned.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    unassigned?: boolean;
    /**
     * Restrict to tasks that have the given key.
     * @type {string}
     * @memberof TaskQueryDto
     */
    taskDefinitionKey?: string;
    /**
     * Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    taskDefinitionKeyIn?: Array<string>;
    /**
     * Restrict to tasks that have a key that has the parameter value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    taskDefinitionKeyLike?: string;
    /**
     * Restrict to tasks that have the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    name?: string;
    /**
     * Restrict to tasks that do not have the given name.
     * @type {string}
     * @memberof TaskQueryDto
     */
    nameNotEqual?: string;
    /**
     * Restrict to tasks that have a name with the given parameter value as substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    nameLike?: string;
    /**
     * Restrict to tasks that do not have a name with the given parameter value as substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    nameNotLike?: string;
    /**
     * Restrict to tasks that have the given description.
     * @type {string}
     * @memberof TaskQueryDto
     */
    description?: string;
    /**
     * Restrict to tasks that have a description that has the parameter value as a substring.
     * @type {string}
     * @memberof TaskQueryDto
     */
    descriptionLike?: string;
    /**
     * Restrict to tasks that have the given priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    priority?: number;
    /**
     * Restrict to tasks that have a lower or equal priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    maxPriority?: number;
    /**
     * Restrict to tasks that have a higher or equal priority.
     * @type {number}
     * @memberof TaskQueryDto
     */
    minPriority?: number;
    /**
     * Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.546+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    dueDate?: Date;
    /**
     * Restrict to tasks that are due on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    dueDateExpression?: string;
    /**
     * Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.435+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    dueAfter?: Date;
    /**
     * Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    dueAfterExpression?: string;
    /**
     * Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.243+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    dueBefore?: Date;
    /**
     * Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    dueBeforeExpression?: string;
    /**
     * Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    followUpDate?: Date;
    /**
     * Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    followUpDateExpression?: string;
    /**
     * Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.542+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    followUpAfter?: Date;
    /**
     * Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    followUpAfterExpression?: string;
    /**
     * Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.234+0200`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    followUpBefore?: string;
    /**
     * Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    followUpBeforeExpression?: string;
    /**
     * Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.432+0200`. The typical use case is to query all `active` tasks for a user for a given date.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    followUpBeforeOrNotExistent?: Date;
    /**
     * Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    followUpBeforeOrNotExistentExpression?: string;
    /**
     * Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.324+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    createdOn?: Date;
    /**
     * Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    createdOnExpression?: string;
    /**
     * Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.342+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    createdAfter?: Date;
    /**
     * Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    createdAfterExpression?: string;
    /**
     * Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format `yyyy-MM-dd'T'HH:mm:ss.SSSZ`, e.g., `2013-01-23T14:42:45.332+0200`.
     * @type {Date}
     * @memberof TaskQueryDto
     */
    createdBefore?: Date;
    /**
     * Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a `java.util.Date` or `org.joda.time.DateTime` object.
     * @type {string}
     * @memberof TaskQueryDto
     */
    createdBeforeExpression?: string;
    /**
     * Restrict to tasks that are in the given delegation state. Valid values are `PENDING` and `RESOLVED`.
     * @type {string}
     * @memberof TaskQueryDto
     */
    delegationState?: TaskQueryDto.DelegationStateEnum;
    /**
     * Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example `developers,support,sales`.
     * @type {Array<string>}
     * @memberof TaskQueryDto
     */
    candidateGroups?: Array<string>;
    /**
     * Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to `java.util.List` of Strings.
     * @type {string}
     * @memberof TaskQueryDto
     */
    candidateGroupsExpression?: string;
    /**
     * Only include tasks which have a candidate group. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    withCandidateGroups?: boolean;
    /**
     * Only include tasks which have no candidate group. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    withoutCandidateGroups?: boolean;
    /**
     * Only include tasks which have a candidate user. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    withCandidateUsers?: boolean;
    /**
     * Only include tasks which have no candidate users. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    withoutCandidateUsers?: boolean;
    /**
     * Only include active tasks. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    active?: boolean;
    /**
     * Only include suspended tasks. Value may only be `true`, as `false` is the default behavior.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    suspended?: boolean;
    /**
     * A JSON array to only include tasks that have variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    taskVariables?: Array<VariableQueryParameterDto>;
    /**
     * A JSON array to only include tasks that belong to a process instance with variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    processVariables?: Array<VariableQueryParameterDto>;
    /**
     * A JSON array to only include tasks that belong to a case instance with variables with certain values. The array consists of JSON objects with three properties `name`, `operator` and `value`. `name` is the variable name, `operator` is the comparison operator to be used and `value` the variable value. `value` may be of type `String`, `Number` or `Boolean`.  Valid `operator` values are: `eq` - equal to; `neq` - not equal to; `gt` - greater than; `gteq` - greater than or equal to; `lt` - lower than; `lteq` - lower than or equal to; `like`. `key` and `value` may not contain underscore or comma characters.
     * @type {Array<VariableQueryParameterDto>}
     * @memberof TaskQueryDto
     */
    caseInstanceVariables?: Array<VariableQueryParameterDto>;
    /**
     * Match all variable names in this query case-insensitively. If set `variableName` and `variablename` are treated as equal.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    variableNamesIgnoreCase?: boolean;
    /**
     * Match all variable values in this query case-insensitively. If set `variableValue` and `variablevalue` are treated as equal.
     * @type {boolean}
     * @memberof TaskQueryDto
     */
    variableValuesIgnoreCase?: boolean;
    /**
     * Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @type {string}
     * @memberof TaskQueryDto
     */
    parentTaskId?: string;
    /**
     * A JSON array of nested task queries with OR semantics. A task matches a nested query if it fulfills *at least one* of the query's predicates. With multiple nested queries, a task must fulfill at least one predicate of *each* query ([Conjunctive Normal Form](https://en.wikipedia.org/wiki/Conjunctive_normal_form)).  All task query properties can be used except for: `sorting`, `withCandidateGroups`, `withoutCandidateGroups`, `withCandidateUsers`, `withoutCandidateUsers`  See the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-engine-api/#or-queries) for more information about OR queries.
     * @type {Array<TaskQueryDto>}
     * @memberof TaskQueryDto
     */
    orQueries?: Array<TaskQueryDto>;
    /**
     * Apply sorting of the result
     * @type {Array<TaskQueryDtoSorting>}
     * @memberof TaskQueryDto
     */
    sorting?: Array<TaskQueryDtoSorting>;
}

/**
 * @export
 * @namespace TaskQueryDto
 */
export namespace TaskQueryDto {
    /**
     * @export
     * @enum {string}
     */
    export enum DelegationStateEnum {
        PENDING = <any> 'PENDING',
        RESOLVED = <any> 'RESOLVED'
    }
}
/**
 * 
 * @export
 * @interface TaskQueryDtoSorting
 */
export interface TaskQueryDtoSorting {
    /**
     * Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @type {string}
     * @memberof TaskQueryDtoSorting
     */
    sortBy?: TaskQueryDtoSorting.SortByEnum;
    /**
     * Sort the results in a given order. Values may be `asc` for ascending order or `desc` for descending order. Must be used in conjunction with the sortBy parameter.
     * @type {string}
     * @memberof TaskQueryDtoSorting
     */
    sortOrder?: TaskQueryDtoSorting.SortOrderEnum;
    /**
     * 
     * @type {SortTaskQueryParametersDto}
     * @memberof TaskQueryDtoSorting
     */
    parameters?: SortTaskQueryParametersDto;
}

/**
 * @export
 * @namespace TaskQueryDtoSorting
 */
export namespace TaskQueryDtoSorting {
    /**
     * @export
     * @enum {string}
     */
    export enum SortByEnum {
        InstanceId = <any> 'instanceId',
        CaseInstanceId = <any> 'caseInstanceId',
        DueDate = <any> 'dueDate',
        ExecutionId = <any> 'executionId',
        CaseExecutionId = <any> 'caseExecutionId',
        Assignee = <any> 'assignee',
        Created = <any> 'created',
        Description = <any> 'description',
        Id = <any> 'id',
        Name = <any> 'name',
        NameCaseInsensitive = <any> 'nameCaseInsensitive',
        Priority = <any> 'priority',
        ProcessVariable = <any> 'processVariable',
        ExecutionVariable = <any> 'executionVariable',
        TaskVariable = <any> 'taskVariable',
        CaseExecutionVariable = <any> 'caseExecutionVariable',
        CaseInstanceVariable = <any> 'caseInstanceVariable'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum SortOrderEnum {
        Asc = <any> 'asc',
        Desc = <any> 'desc'
    }
}
/**
 * A JSON object corresponding to the Activity Instance tree of the given process instance.
 * @export
 * @interface TransitionInstanceDto
 */
export interface TransitionInstanceDto {
    /**
     * The id of the transition instance.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    id?: string;
    /**
     * The id of the parent activity instance, for example a sub process instance.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    parentActivityInstanceId?: string;
    /**
     * The id of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    activityId?: string;
    /**
     * The name of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    activityName?: string;
    /**
     * The type of the activity that this instance enters (asyncBefore job) or leaves (asyncAfter job)
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    activityType?: string;
    /**
     * The id of the process instance this instance is part of.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    processInstanceId?: string;
    /**
     * The id of the process definition.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    processDefinitionId?: string;
    /**
     * The execution id.
     * @type {string}
     * @memberof TransitionInstanceDto
     */
    executionId?: string;
    /**
     * A list of incident ids.
     * @type {Array<string>}
     * @memberof TransitionInstanceDto
     */
    incidentIds?: Array<string>;
    /**
     * A list of JSON objects containing incident specific properties: * `id`: the id of the incident * `activityId`: the activity id in which the incident occurred
     * @type {Array<ActivityInstanceIncidentDto>}
     * @memberof TransitionInstanceDto
     */
    incidents?: Array<ActivityInstanceIncidentDto>;
}
/**
 * 
 * @export
 * @interface TriggerVariableValueDto
 */
export interface TriggerVariableValueDto {
    /**
     * The variable's value. Value differs depending on the variable's type and on the deserializeValues parameter.
     * @type {any}
     * @memberof TriggerVariableValueDto
     */
    value?: any;
    /**
     * The value type of the variable.
     * @type {string}
     * @memberof TriggerVariableValueDto
     */
    type?: string;
    /**
     * A JSON object containing additional, value-type-dependent properties. For serialized variables of type Object, the following properties can be provided:  * `objectTypeName`: A string representation of the object's type name. * `serializationDataFormat`: The serialization format used to store the variable.  For serialized variables of type File, the following properties can be provided:  * `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again. * `mimetype`: The MIME type of the file that is being uploaded. * `encoding`: The encoding of the file that is being uploaded.
     * @type {{ [key: string]: any; }}
     * @memberof TriggerVariableValueDto
     */
    valueInfo?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface UserIdDto
 */
export interface UserIdDto {
    /**
     * The id of the user that the current action refers to.
     * @type {string}
     * @memberof UserIdDto
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface VariableQueryParameterDto
 */
export interface VariableQueryParameterDto {
    /**
     * The variable value, could be of type boolean, string or number
     * @type {any}
     * @memberof VariableQueryParameterDto
     */
    value?: any;
    /**
     * Comparison operator to be used
     * @type {string}
     * @memberof VariableQueryParameterDto
     */
    operator?: VariableQueryParameterDto.OperatorEnum;
}

/**
 * @export
 * @namespace VariableQueryParameterDto
 */
export namespace VariableQueryParameterDto {
    /**
     * @export
     * @enum {string}
     */
    export enum OperatorEnum {
        Eq = <any> 'eq',
        Neq = <any> 'neq',
        Gt = <any> 'gt',
        Gteq = <any> 'gteq',
        Lt = <any> 'lt',
        Lteq = <any> 'lteq',
        Like = <any> 'like'
    }
}
/**
 * 
 * @export
 * @interface VariableValueDto
 */
export interface VariableValueDto {
    /**
     * The variable's value. Value differs depending on the variable's type and on the deserializeValues parameter.
     * @type {any}
     * @memberof VariableValueDto
     */
    value?: any;
    /**
     * The value type of the variable.
     * @type {string}
     * @memberof VariableValueDto
     */
    type?: string;
    /**
     * A JSON object containing additional, value-type-dependent properties. For serialized variables of type Object, the following properties can be provided:  * `objectTypeName`: A string representation of the object's type name. * `serializationDataFormat`: The serialization format used to store the variable.  For serialized variables of type File, the following properties can be provided:  * `filename`: The name of the file. This is not the variable name but the name that will be used when downloading the file again. * `mimetype`: The MIME type of the file that is being uploaded. * `encoding`: The encoding of the file that is being uploaded.
     * @type {{ [key: string]: any; }}
     * @memberof VariableValueDto
     */
    valueInfo?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface VersionDto
 */
export interface VersionDto {
    /**
     * The version of the Rest API.
     * @type {string}
     * @memberof VersionDto
     */
    version?: string;
}
/**
 * ConditionApi - fetch parameter creator
 * @export
 */
export const ConditionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition(body?: EvaluationConditionDto, options: any = {}): FetchArgs {
            const localVarPath = `/condition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"EvaluationConditionDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConditionApi - functional programming interface
 * @export
 */
export const ConditionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition(body?: EvaluationConditionDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessInstanceDto>> {
            const localVarFetchArgs = ConditionApiFetchParamCreator(configuration).evaluateCondition(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ConditionApi - factory interface
 * @export
 */
export const ConditionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {EvaluationConditionDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        evaluateCondition(body?: EvaluationConditionDto, options?: any) {
            return ConditionApiFp(configuration).evaluateCondition(body, options)(fetch, basePath);
        },
    };
};

/**
 * ConditionApi - object-oriented interface
 * @export
 * @class ConditionApi
 * @extends {BaseAPI}
 */
export class ConditionApi extends BaseAPI {
    /**
     * Triggers evaluation of conditions for conditional start event(s).  Internally this maps to the engines condition evaluation builder method ConditionEvaluationBuilder#evaluateStartConditions().  For more information see the [Conditional Start Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/conditional-events/#conditional-start-event) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {EvaluationConditionDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConditionApi
     */
    public evaluateCondition(body?: EvaluationConditionDto, options?: any) {
        return ConditionApiFp(this.configuration).evaluateCondition(body, options)(this.fetch, this.basePath);
    }

}
/**
 * DeploymentApi - fetch parameter creator
 * @export
 */
export const DeploymentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] 
         * @param {string} [deploymentSource] 
         * @param {boolean} [deployChangedOnly] 
         * @param {boolean} [enableDuplicateFiltering] 
         * @param {string} [deploymentName] 
         * @param {Blob} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: Blob, options: any = {}): FetchArgs {
            const localVarPath = `/deployment/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (tenantId !== undefined) {
                localVarFormParams.set('tenant-id', tenantId as any);
            }

            if (deploymentSource !== undefined) {
                localVarFormParams.set('deployment-source', deploymentSource as any);
            }

            if (deployChangedOnly !== undefined) {
                localVarFormParams.set('deploy-changed-only', deployChangedOnly as any);
            }

            if (enableDuplicateFiltering !== undefined) {
                localVarFormParams.set('enable-duplicate-filtering', enableDuplicateFiltering as any);
            }

            if (deploymentName !== undefined) {
                localVarFormParams.set('deployment-name', deploymentName as any);
            }

            if (data !== undefined) {
                localVarFormParams.set('data', data as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDeployment.');
            }
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeployment.');
            }
            const localVarPath = `/deployment/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource(id: string, resourceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeploymentResource.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling getDeploymentResource.');
            }
            const localVarPath = `/deployment/{id}/resources/{resourceId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData(id: string, resourceId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeploymentResourceData.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling getDeploymentResourceData.');
            }
            const localVarPath = `/deployment/{id}/resources/{resourceId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeploymentResources.');
            }
            const localVarPath = `/deployment/{id}/resources`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/deployment`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any).toISOString();
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any).toISOString();
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, options: any = {}): FetchArgs {
            const localVarPath = `/deployment/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (withoutSource !== undefined) {
                localVarQueryParameter['withoutSource'] = withoutSource;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeDeploymentsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeDeploymentsWithoutTenantId'] = includeDeploymentsWithoutTenantId;
            }

            if (after !== undefined) {
                localVarQueryParameter['after'] = (after as any).toISOString();
            }

            if (before !== undefined) {
                localVarQueryParameter['before'] = (before as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy(id: string, body?: RedeploymentDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling redeploy.');
            }
            const localVarPath = `/deployment/{id}/redeploy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RedeploymentDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeploymentApi - functional programming interface
 * @export
 */
export const DeploymentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] 
         * @param {string} [deploymentSource] 
         * @param {boolean} [deployChangedOnly] 
         * @param {boolean} [enableDuplicateFiltering] 
         * @param {string} [deploymentName] 
         * @param {Blob} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentWithDefinitionsDto> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeploymentDto>> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeployment(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource(id: string, resourceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentResourceDto> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeploymentResource(id, resourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData(id: string, resourceId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeploymentResourceData(id, resourceId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeploymentResourceDto>> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeploymentResources(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<DeploymentDto>> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy(id: string, body?: RedeploymentDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<DeploymentWithDefinitionsDto> {
            const localVarFetchArgs = DeploymentApiFetchParamCreator(configuration).redeploy(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DeploymentApi - factory interface
 * @export
 */
export const DeploymentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
         * @param {string} [tenantId] 
         * @param {string} [deploymentSource] 
         * @param {boolean} [deployChangedOnly] 
         * @param {boolean} [enableDuplicateFiltering] 
         * @param {string} [deploymentName] 
         * @param {Blob} [data] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: Blob, options?: any) {
            return DeploymentApiFp(configuration).createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options)(fetch, basePath);
        },
        /**
         * Deletes a deployment by id.
         * @param {string} id The id of the deployment to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
            return DeploymentApiFp(configuration).deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options)(fetch, basePath);
        },
        /**
         * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
         * @param {string} id The id of the deployment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployment(id: string, options?: any) {
            return DeploymentApiFp(configuration).getDeployment(id, options)(fetch, basePath);
        },
        /**
         * Retrieves a deployment resource by resource id for the given deployment.
         * @param {string} id The id of the deployment
         * @param {string} resourceId The id of the deployment resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResource(id: string, resourceId: string, options?: any) {
            return DeploymentApiFp(configuration).getDeploymentResource(id, resourceId, options)(fetch, basePath);
        },
        /**
         * Retrieves the binary content of a deployment resource for the given deployment by id.
         * @param {string} id The id of the deployment.
         * @param {string} resourceId The id of the deployment resource.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResourceData(id: string, resourceId: string, options?: any) {
            return DeploymentApiFp(configuration).getDeploymentResourceData(id, resourceId, options)(fetch, basePath);
        },
        /**
         * Retrieves all deployment resources of a given deployment.
         * @param {string} id The id of the deployment to retrieve the deployment resources for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentResources(id: string, options?: any) {
            return DeploymentApiFp(configuration).getDeploymentResources(id, options)(fetch, basePath);
        },
        /**
         * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
            return DeploymentApiFp(configuration).getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
         * @param {string} [id] Filter by deployment id
         * @param {string} [name] Filter by the deployment name. Exact match.
         * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
         * @param {string} [source] Filter by the deployment source.
         * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, options?: any) {
            return DeploymentApiFp(configuration).getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options)(fetch, basePath);
        },
        /**
         * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {string} id The id of the deployment to re-deploy.
         * @param {RedeploymentDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redeploy(id: string, body?: RedeploymentDto, options?: any) {
            return DeploymentApiFp(configuration).redeploy(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * DeploymentApi - object-oriented interface
 * @export
 * @class DeploymentApi
 * @extends {BaseAPI}
 */
export class DeploymentApi extends BaseAPI {
    /**
     * Creates a deployment.  **Security Consideration**  Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code.
     * @param {string} [tenantId] 
     * @param {string} [deploymentSource] 
     * @param {boolean} [deployChangedOnly] 
     * @param {boolean} [enableDuplicateFiltering] 
     * @param {string} [deploymentName] 
     * @param {Blob} [data] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public createDeployment(tenantId?: string, deploymentSource?: string, deployChangedOnly?: boolean, enableDuplicateFiltering?: boolean, deploymentName?: string, data?: Blob, options?: any) {
        return DeploymentApiFp(this.configuration).createDeployment(tenantId, deploymentSource, deployChangedOnly, enableDuplicateFiltering, deploymentName, data, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a deployment by id.
     * @param {string} id The id of the deployment to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this deployment should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] &#x60;true&#x60;, if all input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public deleteDeployment(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
        return DeploymentApiFp(this.configuration).deleteDeployment(id, cascade, skipCustomListeners, skipIoMappings, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a deployment by id, according to the `Deployment` interface of the engine.
     * @param {string} id The id of the deployment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployment(id: string, options?: any) {
        return DeploymentApiFp(this.configuration).getDeployment(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a deployment resource by resource id for the given deployment.
     * @param {string} id The id of the deployment
     * @param {string} resourceId The id of the deployment resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResource(id: string, resourceId: string, options?: any) {
        return DeploymentApiFp(this.configuration).getDeploymentResource(id, resourceId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the binary content of a deployment resource for the given deployment by id.
     * @param {string} id The id of the deployment.
     * @param {string} resourceId The id of the deployment resource.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResourceData(id: string, resourceId: string, options?: any) {
        return DeploymentApiFp(this.configuration).getDeploymentResourceData(id, resourceId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves all deployment resources of a given deployment.
     * @param {string} id The id of the deployment to retrieve the deployment resources for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentResources(id: string, options?: any) {
        return DeploymentApiFp(this.configuration).getDeploymentResources(id, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for deployments that fulfill given parameters. Parameters may be the properties of deployments, such as the id or name or a range of the deployment time. The size of the result set can be retrieved by using the [Get Deployment count](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query-count/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeployments(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
        return DeploymentApiFp(this.configuration).getDeployments(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, sortBy, sortOrder, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of deployments that fulfill given parameters. Takes the same parameters as the [Get Deployments](https://docs.camunda.org/manual/7.13/reference/rest/deployment/get-query/) method.
     * @param {string} [id] Filter by deployment id
     * @param {string} [name] Filter by the deployment name. Exact match.
     * @param {string} [nameLike] Filter by the deployment name that the parameter is a substring of. The parameter can include the wildcard &#x60;%&#x60; to express like-strategy such as: starts with (&#x60;%&#x60;name), ends with (name&#x60;%&#x60;) or contains (&#x60;%&#x60;name&#x60;%&#x60;).
     * @param {string} [source] Filter by the deployment source.
     * @param {boolean} [withoutSource] Filter by the deployment source whereby source is equal to &#x60;null&#x60;.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A deployment must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include deployments which belong to no tenant. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeDeploymentsWithoutTenantId] Include deployments which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {Date} [after] Restricts to all deployments after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [before] Restricts to all deployments before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public getDeploymentsCount(id?: string, name?: string, nameLike?: string, source?: string, withoutSource?: boolean, tenantIdIn?: string, withoutTenantId?: boolean, includeDeploymentsWithoutTenantId?: boolean, after?: Date, before?: Date, options?: any) {
        return DeploymentApiFp(this.configuration).getDeploymentsCount(id, name, nameLike, source, withoutSource, tenantIdIn, withoutTenantId, includeDeploymentsWithoutTenantId, after, before, options)(this.fetch, this.basePath);
    }

    /**
     * Re-deploys an existing deployment.  The deployment resources to re-deploy can be restricted by using the properties `resourceIds` or `resourceNames`. If no deployment resources to re-deploy are passed then all existing resources of the given deployment are re-deployed.  **Warning**: Deployments can contain custom code in form of scripts or EL expressions to customize process behavior. This may be abused for remote execution of arbitrary code. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {string} id The id of the deployment to re-deploy.
     * @param {RedeploymentDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeploymentApi
     */
    public redeploy(id: string, body?: RedeploymentDto, options?: any) {
        return DeploymentApiFp(this.configuration).redeploy(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * EngineApi - fetch parameter creator
 * @export
 */
export const EngineApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames(options: any = {}): FetchArgs {
            const localVarPath = `/engine`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EngineApi - functional programming interface
 * @export
 */
export const EngineApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessEngineDto>> {
            const localVarFetchArgs = EngineApiFetchParamCreator(configuration).getProcessEngineNames(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EngineApi - factory interface
 * @export
 */
export const EngineApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessEngineNames(options?: any) {
            return EngineApiFp(configuration).getProcessEngineNames(options)(fetch, basePath);
        },
    };
};

/**
 * EngineApi - object-oriented interface
 * @export
 * @class EngineApi
 * @extends {BaseAPI}
 */
export class EngineApi extends BaseAPI {
    /**
     * Retrieves the names of all process engines available on your platform. **Note**: You cannot prepend `/engine/{name}` to this method.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EngineApi
     */
    public getProcessEngineNames(options?: any) {
        return EngineApiFp(this.configuration).getProcessEngineNames(options)(this.fetch, this.basePath);
    }

}
/**
 * EventSubscriptionApi - fetch parameter creator
 * @export
 */
export const EventSubscriptionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/event-subscription`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/event-subscription/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (eventSubscriptionId !== undefined) {
                localVarQueryParameter['eventSubscriptionId'] = eventSubscriptionId;
            }

            if (eventName !== undefined) {
                localVarQueryParameter['eventName'] = eventName;
            }

            if (eventType !== undefined) {
                localVarQueryParameter['eventType'] = eventType;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeEventSubscriptionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeEventSubscriptionsWithoutTenantId'] = includeEventSubscriptionsWithoutTenantId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventSubscriptionApi - functional programming interface
 * @export
 */
export const EventSubscriptionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<EventSubscriptionDto>> {
            const localVarFetchArgs = EventSubscriptionApiFetchParamCreator(configuration).getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = EventSubscriptionApiFetchParamCreator(configuration).getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EventSubscriptionApi - factory interface
 * @export
 */
export const EventSubscriptionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
            return EventSubscriptionApiFp(configuration).getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
         * @param {string} [eventSubscriptionId] Only select subscription with the given id.
         * @param {string} [eventName] Only select subscriptions for events with the given name.
         * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
         * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
         * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
         * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: any) {
            return EventSubscriptionApiFp(configuration).getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options)(fetch, basePath);
        },
    };
};

/**
 * EventSubscriptionApi - object-oriented interface
 * @export
 * @class EventSubscriptionApi
 * @extends {BaseAPI}
 */
export class EventSubscriptionApi extends BaseAPI {
    /**
     * Queries for event subscriptions that fulfill given parameters. The size of the result set can be retrieved by using the [Get Event Subscriptions count](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query-count/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    public getEventSubscriptions(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
        return EventSubscriptionApiFp(this.configuration).getEventSubscriptions(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, sortBy, sortOrder, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of event subscriptions that fulfill given parameters. Takes the same parameters as the [Get Event Subscriptions](https://docs.camunda.org/manual/7.13/reference/rest/event-subscription/get-query/) method.
     * @param {string} [eventSubscriptionId] Only select subscription with the given id.
     * @param {string} [eventName] Only select subscriptions for events with the given name.
     * @param {string} [eventType] Only select subscriptions for events with the given type. Valid values: &#x60;message&#x60;, &#x60;signal&#x60;, &#x60;compensate&#x60; and &#x60;conditional&#x60;.
     * @param {string} [executionId] Only select subscriptions that belong to an execution with the given id.
     * @param {string} [processInstanceId] Only select subscriptions that belong to a process instance with the given id.
     * @param {string} [activityId] Only select subscriptions that belong to an activity with the given id.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. Only select subscriptions that belong to one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only select subscriptions which have no tenant id. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [includeEventSubscriptionsWithoutTenantId] Select event subscriptions which have no tenant id. Can be used in combination with tenantIdIn parameter. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventSubscriptionApi
     */
    public getEventSubscriptionsCount(eventSubscriptionId?: string, eventName?: string, eventType?: string, executionId?: string, processInstanceId?: string, activityId?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeEventSubscriptionsWithoutTenantId?: boolean, options?: any) {
        return EventSubscriptionApiFp(this.configuration).getEventSubscriptionsCount(eventSubscriptionId, eventName, eventType, executionId, processInstanceId, activityId, tenantIdIn, withoutTenantId, includeEventSubscriptionsWithoutTenantId, options)(this.fetch, this.basePath);
    }

}
/**
 * ExternalTaskApi - fetch parameter creator
 * @export
 */
export const ExternalTaskApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource(id: string, body?: CompleteExternalTaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling completeExternalTaskResource.');
            }
            const localVarPath = `/external-task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompleteExternalTaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock(id: string, body?: ExtendLockOnExternalTaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling extendLock.');
            }
            const localVarPath = `/external-task/{id}/extendLock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExtendLockOnExternalTaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock(body?: FetchExternalTasksDto, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/fetchAndLock`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"FetchExternalTasksDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExternalTask.');
            }
            const localVarPath = `/external-task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getExternalTaskErrorDetails.');
            }
            const localVarPath = `/external-task/{id}/errorDetails`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/external-task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }

            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter as any).toISOString();
            }

            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore as any).toISOString();
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (externalTaskId !== undefined) {
                localVarQueryParameter['externalTaskId'] = externalTaskId;
            }

            if (externalTaskIdIn !== undefined) {
                localVarQueryParameter['externalTaskIdIn'] = externalTaskIdIn;
            }

            if (topicName !== undefined) {
                localVarQueryParameter['topicName'] = topicName;
            }

            if (workerId !== undefined) {
                localVarQueryParameter['workerId'] = workerId;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }

            if (notLocked !== undefined) {
                localVarQueryParameter['notLocked'] = notLocked;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            if (noRetriesLeft !== undefined) {
                localVarQueryParameter['noRetriesLeft'] = noRetriesLeft;
            }

            if (lockExpirationAfter !== undefined) {
                localVarQueryParameter['lockExpirationAfter'] = (lockExpirationAfter as any).toISOString();
            }

            if (lockExpirationBefore !== undefined) {
                localVarQueryParameter['lockExpirationBefore'] = (lockExpirationBefore as any).toISOString();
            }

            if (activityId !== undefined) {
                localVarQueryParameter['activityId'] = activityId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (priorityHigherThanOrEquals !== undefined) {
                localVarQueryParameter['priorityHigherThanOrEquals'] = priorityHigherThanOrEquals;
            }

            if (priorityLowerThanOrEquals !== undefined) {
                localVarQueryParameter['priorityLowerThanOrEquals'] = priorityLowerThanOrEquals;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/topic-names`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (withLockedTasks !== undefined) {
                localVarQueryParameter['withLockedTasks'] = withLockedTasks;
            }

            if (withUnlockedTasks !== undefined) {
                localVarQueryParameter['withUnlockedTasks'] = withUnlockedTasks;
            }

            if (withRetriesLeft !== undefined) {
                localVarQueryParameter['withRetriesLeft'] = withRetriesLeft;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError(id: string, body?: ExternalTaskBpmnError, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleExternalTaskBpmnError.');
            }
            const localVarPath = `/external-task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExternalTaskBpmnError" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure(id: string, body?: ExternalTaskFailureDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleFailure.');
            }
            const localVarPath = `/external-task/{id}/failure`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExternalTaskFailureDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks(body?: ExternalTaskQueryDto, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/external-task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExternalTaskQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount(body?: ExternalTaskQueryDto, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ExternalTaskQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority(id: string, body?: PriorityDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setExternalTaskResourcePriority.');
            }
            const localVarPath = `/external-task/{id}/priority`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PriorityDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries(id: string, body?: RetriesDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setExternalTaskResourceRetries.');
            }
            const localVarPath = `/external-task/{id}/retries`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RetriesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries(body?: SetRetriesForExternalTasksDto, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/retries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetRetriesForExternalTasksDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation(body?: SetRetriesForExternalTasksDto, options: any = {}): FetchArgs {
            const localVarPath = `/external-task/retries-async`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetRetriesForExternalTasksDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unlocks an external task by id. Clears the task's lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unlock.');
            }
            const localVarPath = `/external-task/{id}/unlock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExternalTaskApi - functional programming interface
 * @export
 */
export const ExternalTaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource(id: string, body?: CompleteExternalTaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).completeExternalTaskResource(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock(id: string, body?: ExtendLockOnExternalTaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).extendLock(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock(body?: FetchExternalTasksDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<LockedExternalTaskDto>> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).fetchAndLock(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ExternalTaskDto> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).getExternalTask(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).getExternalTaskErrorDetails(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExternalTaskDto>> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<string>> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError(id: string, body?: ExternalTaskBpmnError, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).handleExternalTaskBpmnError(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure(id: string, body?: ExternalTaskFailureDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).handleFailure(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks(body?: ExternalTaskQueryDto, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ExternalTaskDto>> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).queryExternalTasks(body, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount(body?: ExternalTaskQueryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).queryExternalTasksCount(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority(id: string, body?: PriorityDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).setExternalTaskResourcePriority(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries(id: string, body?: RetriesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).setExternalTaskResourceRetries(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries(body?: SetRetriesForExternalTasksDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).setExternalTaskRetries(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation(body?: SetRetriesForExternalTasksDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).setExternalTaskRetriesAsyncOperation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Unlocks an external task by id. Clears the task's lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ExternalTaskApiFetchParamCreator(configuration).unlock(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExternalTaskApi - factory interface
 * @export
 */
export const ExternalTaskApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Completes an external task by id and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeExternalTaskResource(id: string, body?: CompleteExternalTaskDto, options?: any) {
            return ExternalTaskApiFp(configuration).completeExternalTaskResource(id, body, options)(fetch, basePath);
        },
        /**
         * Extends the timeout of the lock by a given amount of time.
         * @param {string} id The id of the external task.
         * @param {ExtendLockOnExternalTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extendLock(id: string, body?: ExtendLockOnExternalTaskDto, options?: any) {
            return ExternalTaskApiFp(configuration).extendLock(id, body, options)(fetch, basePath);
        },
        /**
         * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
         * @param {FetchExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAndLock(body?: FetchExternalTasksDto, options?: any) {
            return ExternalTaskApiFp(configuration).fetchAndLock(body, options)(fetch, basePath);
        },
        /**
         * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
         * @param {string} id The id of the external task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTask(id: string, options?: any) {
            return ExternalTaskApiFp(configuration).getExternalTask(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the error details in the context of a running external task by id.
         * @param {string} id The id of the external task for which the error details should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTaskErrorDetails(id: string, options?: any) {
            return ExternalTaskApiFp(configuration).getExternalTaskErrorDetails(id, options)(fetch, basePath);
        },
        /**
         * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
            return ExternalTaskApiFp(configuration).getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
         * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
         * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
         * @param {string} [topicName] Filter by an external task topic.
         * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
         * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
         * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
         * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
         * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
         * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
         * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
         * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: any) {
            return ExternalTaskApiFp(configuration).getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options)(fetch, basePath);
        },
        /**
         * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
         * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: any) {
            return ExternalTaskApiFp(configuration).getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options)(fetch, basePath);
        },
        /**
         * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
         * @param {string} id The id of the external task in which context a BPMN error is reported.
         * @param {ExternalTaskBpmnError} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleExternalTaskBpmnError(id: string, body?: ExternalTaskBpmnError, options?: any) {
            return ExternalTaskApiFp(configuration).handleExternalTaskBpmnError(id, body, options)(fetch, basePath);
        },
        /**
         * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
         * @param {string} id The id of the external task to report a failure for.
         * @param {ExternalTaskFailureDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleFailure(id: string, body?: ExternalTaskFailureDto, options?: any) {
            return ExternalTaskApiFp(configuration).handleFailure(id, body, options)(fetch, basePath);
        },
        /**
         * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasks(body?: ExternalTaskQueryDto, firstResult?: number, maxResults?: number, options?: any) {
            return ExternalTaskApiFp(configuration).queryExternalTasks(body, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
         * @param {ExternalTaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryExternalTasksCount(body?: ExternalTaskQueryDto, options?: any) {
            return ExternalTaskApiFp(configuration).queryExternalTasksCount(body, options)(fetch, basePath);
        },
        /**
         * Sets the priority of an existing external task by id. The default value of a priority is 0.
         * @param {string} id The id of the external task to set the priority for.
         * @param {PriorityDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourcePriority(id: string, body?: PriorityDto, options?: any) {
            return ExternalTaskApiFp(configuration).setExternalTaskResourcePriority(id, body, options)(fetch, basePath);
        },
        /**
         * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
         * @param {string} id The id of the external task to set the number of retries for.
         * @param {RetriesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskResourceRetries(id: string, body?: RetriesDto, options?: any) {
            return ExternalTaskApiFp(configuration).setExternalTaskResourceRetries(id, body, options)(fetch, basePath);
        },
        /**
         * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetries(body?: SetRetriesForExternalTasksDto, options?: any) {
            return ExternalTaskApiFp(configuration).setExternalTaskRetries(body, options)(fetch, basePath);
        },
        /**
         * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
         * @param {SetRetriesForExternalTasksDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setExternalTaskRetriesAsyncOperation(body?: SetRetriesForExternalTasksDto, options?: any) {
            return ExternalTaskApiFp(configuration).setExternalTaskRetriesAsyncOperation(body, options)(fetch, basePath);
        },
        /**
         * Unlocks an external task by id. Clears the task's lock expiration time and worker id.
         * @param {string} id The id of the external task to unlock.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unlock(id: string, options?: any) {
            return ExternalTaskApiFp(configuration).unlock(id, options)(fetch, basePath);
        },
    };
};

/**
 * ExternalTaskApi - object-oriented interface
 * @export
 * @class ExternalTaskApi
 * @extends {BaseAPI}
 */
export class ExternalTaskApi extends BaseAPI {
    /**
     * Completes an external task by id and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteExternalTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public completeExternalTaskResource(id: string, body?: CompleteExternalTaskDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).completeExternalTaskResource(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Extends the timeout of the lock by a given amount of time.
     * @param {string} id The id of the external task.
     * @param {ExtendLockOnExternalTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public extendLock(id: string, body?: ExtendLockOnExternalTaskDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).extendLock(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Fetches and locks a specific number of external tasks for execution by a worker. Query can be restricted to specific task topics and for each task topic an individual lock time can be provided.
     * @param {FetchExternalTasksDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public fetchAndLock(body?: FetchExternalTasksDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).fetchAndLock(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves an external task by id, corresponding to the `ExternalTask` interface in the engine.
     * @param {string} id The id of the external task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTask(id: string, options?: any) {
        return ExternalTaskApiFp(this.configuration).getExternalTask(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the error details in the context of a running external task by id.
     * @param {string} id The id of the external task for which the error details should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTaskErrorDetails(id: string, options?: any) {
        return ExternalTaskApiFp(this.configuration).getExternalTaskErrorDetails(id, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the external tasks that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of executions. The size of the result set can be retrieved by using the [Get External Task Count](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query-count/) method.
     * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTasks(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
        return ExternalTaskApiFp(this.configuration).getExternalTasks(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, sortBy, sortOrder, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of external tasks that fulfill given parameters. Takes the same parameters as the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method.
     * @param {string} [externalTaskId] Filter by an external task&#x27;s id.
     * @param {string} [externalTaskIdIn] Filter by the comma-separated list of external task ids.
     * @param {string} [topicName] Filter by an external task topic.
     * @param {string} [workerId] Filter by the id of the worker that the task was most recently locked by.
     * @param {boolean} [locked] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [notLocked] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [noRetriesLeft] Only include external tasks that have 0 retries. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {Date} [lockExpirationAfter] Restrict to external tasks that have a lock that expires after a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {Date} [lockExpirationBefore] Restrict to external tasks that have a lock that expires before a given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.000+0200&#x60;.
     * @param {string} [activityId] Filter by the id of the activity that an external task is created for.
     * @param {string} [activityIdIn] Filter by the comma-separated list of ids of the activities that an external task is created for.
     * @param {string} [executionId] Filter by the id of the execution that an external task belongs to.
     * @param {string} [processInstanceId] Filter by the id of the process instance that an external task belongs to.
     * @param {string} [processInstanceIdIn] Filter by a comma-separated list of process instance ids that an external task may belong to.
     * @param {string} [processDefinitionId] Filter by the id of the process definition that an external task belongs to.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. An external task must have one of the given tenant ids.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {number} [priorityHigherThanOrEquals] Only include jobs with a priority higher than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {number} [priorityLowerThanOrEquals] Only include jobs with a priority lower than or equal to the given value. Value must be a valid &#x60;long&#x60; value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getExternalTasksCount(externalTaskId?: string, externalTaskIdIn?: string, topicName?: string, workerId?: string, locked?: boolean, notLocked?: boolean, withRetriesLeft?: boolean, noRetriesLeft?: boolean, lockExpirationAfter?: Date, lockExpirationBefore?: Date, activityId?: string, activityIdIn?: string, executionId?: string, processInstanceId?: string, processInstanceIdIn?: string, processDefinitionId?: string, tenantIdIn?: string, active?: boolean, suspended?: boolean, priorityHigherThanOrEquals?: number, priorityLowerThanOrEquals?: number, options?: any) {
        return ExternalTaskApiFp(this.configuration).getExternalTasksCount(externalTaskId, externalTaskIdIn, topicName, workerId, locked, notLocked, withRetriesLeft, noRetriesLeft, lockExpirationAfter, lockExpirationBefore, activityId, activityIdIn, executionId, processInstanceId, processInstanceIdIn, processDefinitionId, tenantIdIn, active, suspended, priorityHigherThanOrEquals, priorityLowerThanOrEquals, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for distinct topic names of external tasks that fulfill given parameters. Query can be restricted to only tasks with retries left, tasks that are locked, or tasks that are unlocked. The parameters withLockedTasks and withUnlockedTasks are exclusive. Setting them both to true will return an empty list. Providing no parameters will return a list of all distinct topic names with external tasks.
     * @param {boolean} [withLockedTasks] Only include external tasks that are currently locked (i.e., they have a lock time and it has not expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withUnlockedTasks] Only include external tasks that are currently not locked (i.e., they have no lock or it has expired). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {boolean} [withRetriesLeft] Only include external tasks that have a positive (&amp;gt; 0) number of retries (or &#x60;null&#x60;). Value may only be &#x60;true&#x60;, as &#x60;false&#x60; matches any external task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public getTopicNames(withLockedTasks?: boolean, withUnlockedTasks?: boolean, withRetriesLeft?: boolean, options?: any) {
        return ExternalTaskApiFp(this.configuration).getTopicNames(withLockedTasks, withUnlockedTasks, withRetriesLeft, options)(this.fetch, this.basePath);
    }

    /**
     * Reports a business error in the context of a running external task by id. The error code must be specified to identify the BPMN error handler.
     * @param {string} id The id of the external task in which context a BPMN error is reported.
     * @param {ExternalTaskBpmnError} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public handleExternalTaskBpmnError(id: string, body?: ExternalTaskBpmnError, options?: any) {
        return ExternalTaskApiFp(this.configuration).handleExternalTaskBpmnError(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Reports a failure to execute an external task by id. A number of retries and a timeout until the task can be retried can be specified. If retries are set to 0, an incident for this task is created.
     * @param {string} id The id of the external task to report a failure for.
     * @param {ExternalTaskFailureDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public handleFailure(id: string, body?: ExternalTaskFailureDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).handleFailure(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for external tasks that fulfill given parameters in the form of a JSON object.  This method is slightly more powerful than the [Get External Tasks](https://docs.camunda.org/manual/7.13/reference/rest/external-task/get-query/) method because it allows to specify a hierarchical result sorting.
     * @param {ExternalTaskQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public queryExternalTasks(body?: ExternalTaskQueryDto, firstResult?: number, maxResults?: number, options?: any) {
        return ExternalTaskApiFp(this.configuration).queryExternalTasks(body, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of external tasks that fulfill given parameters. This method takes the same message body as the [Get External Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/external-task/post-query/) method.
     * @param {ExternalTaskQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public queryExternalTasksCount(body?: ExternalTaskQueryDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).queryExternalTasksCount(body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the priority of an existing external task by id. The default value of a priority is 0.
     * @param {string} id The id of the external task to set the priority for.
     * @param {PriorityDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskResourcePriority(id: string, body?: PriorityDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskResourcePriority(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the number of retries left to execute an external task by id. If retries are set to 0, an  incident is created.
     * @param {string} id The id of the external task to set the number of retries for.
     * @param {RetriesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskResourceRetries(id: string, body?: RetriesDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskResourceRetries(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the number of retries left to execute external tasks by id synchronously. If retries are set to 0,  an incident is created.
     * @param {SetRetriesForExternalTasksDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskRetries(body?: SetRetriesForExternalTasksDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskRetries(body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the number of retries left to execute external tasks by id asynchronously. If retries are set to 0, an incident is created.
     * @param {SetRetriesForExternalTasksDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public setExternalTaskRetriesAsyncOperation(body?: SetRetriesForExternalTasksDto, options?: any) {
        return ExternalTaskApiFp(this.configuration).setExternalTaskRetriesAsyncOperation(body, options)(this.fetch, this.basePath);
    }

    /**
     * Unlocks an external task by id. Clears the task's lock expiration time and worker id.
     * @param {string} id The id of the external task to unlock.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExternalTaskApi
     */
    public unlock(id: string, options?: any) {
        return ExternalTaskApiFp(this.configuration).unlock(id, options)(this.fetch, this.basePath);
    }

}
/**
 * MessageApi - fetch parameter creator
 * @export
 */
export const MessageApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine's message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage(body?: CorrelationMessageDto, options: any = {}): FetchArgs {
            const localVarPath = `/message`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CorrelationMessageDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MessageApi - functional programming interface
 * @export
 */
export const MessageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine's message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage(body?: CorrelationMessageDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MessageCorrelationResultWithVariableDto>> {
            const localVarFetchArgs = MessageApiFetchParamCreator(configuration).deliverMessage(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MessageApi - factory interface
 * @export
 */
export const MessageApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine's message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {CorrelationMessageDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliverMessage(body?: CorrelationMessageDto, options?: any) {
            return MessageApiFp(configuration).deliverMessage(body, options)(fetch, basePath);
        },
    };
};

/**
 * MessageApi - object-oriented interface
 * @export
 * @class MessageApi
 * @extends {BaseAPI}
 */
export class MessageApi extends BaseAPI {
    /**
     * Correlates a message to the process engine to either trigger a message start event or an intermediate message  catching event. Internally this maps to the engine's message correlation builder methods `MessageCorrelationBuilder#correlateWithResult()` and `MessageCorrelationBuilder#correlateAllWithResult()`. For more information about the correlation behavior, see the [Message Events](https://docs.camunda.org/manual/7.13/bpmn20/events/message-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {CorrelationMessageDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MessageApi
     */
    public deliverMessage(body?: CorrelationMessageDto, options?: any) {
        return MessageApiFp(this.configuration).deliverMessage(body, options)(this.fetch, this.basePath);
    }

}
/**
 * MetricsApi - fetch parameter creator
 * @export
 */
export const MetricsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {string} metricsName The name of the metric.
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metricsName: string, startDate?: Date, endDate?: Date, options: any = {}): FetchArgs {
            // verify required parameter 'metricsName' is not null or undefined
            if (metricsName === null || metricsName === undefined) {
                throw new RequiredError('metricsName','Required parameter metricsName was null or undefined when calling getMetrics.');
            }
            const localVarPath = `/metrics/{metrics-name}/sum`
                .replace(`{${"metrics-name"}}`, encodeURIComponent(String(metricsName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {string} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval(name?: string, reporter?: string, startDate?: Date, endDate?: Date, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options: any = {}): FetchArgs {
            const localVarPath = `/metrics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (reporter !== undefined) {
                localVarQueryParameter['reporter'] = reporter;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate as any).toISOString();
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate as any).toISOString();
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (aggregateByReporter !== undefined) {
                localVarQueryParameter['aggregateByReporter'] = aggregateByReporter;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetricsApi - functional programming interface
 * @export
 */
export const MetricsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {string} metricsName The name of the metric.
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metricsName: string, startDate?: Date, endDate?: Date, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MetricsResultDto> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).getMetrics(metricsName, startDate, endDate, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {string} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval(name?: string, reporter?: string, startDate?: Date, endDate?: Date, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<MetricsIntervalResultDto>> {
            const localVarFetchArgs = MetricsApiFetchParamCreator(configuration).interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MetricsApi - factory interface
 * @export
 */
export const MetricsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves the `sum` (count) for a given metric.
         * @param {string} metricsName The name of the metric.
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetrics(metricsName: string, startDate?: Date, endDate?: Date, options?: any) {
            return MetricsApiFp(configuration).getMetrics(metricsName, startDate, endDate, options)(fetch, basePath);
        },
        /**
         * Retrieves a list of metrics, aggregated for a given interval.
         * @param {string} [name] The name of the metric.
         * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
         * @param {Date} [startDate] The start date (inclusive).
         * @param {Date} [endDate] The end date (exclusive).
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
         * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interval(name?: string, reporter?: string, startDate?: Date, endDate?: Date, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: any) {
            return MetricsApiFp(configuration).interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options)(fetch, basePath);
        },
    };
};

/**
 * MetricsApi - object-oriented interface
 * @export
 * @class MetricsApi
 * @extends {BaseAPI}
 */
export class MetricsApi extends BaseAPI {
    /**
     * Retrieves the `sum` (count) for a given metric.
     * @param {string} metricsName The name of the metric.
     * @param {Date} [startDate] The start date (inclusive).
     * @param {Date} [endDate] The end date (exclusive).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public getMetrics(metricsName: string, startDate?: Date, endDate?: Date, options?: any) {
        return MetricsApiFp(this.configuration).getMetrics(metricsName, startDate, endDate, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a list of metrics, aggregated for a given interval.
     * @param {string} [name] The name of the metric.
     * @param {string} [reporter] The name of the reporter (host), on which the metrics was logged. This will have value provided by the [hostname configuration property](https://docs.camunda.org/manual/7.13/reference/deployment-descriptors/tags/process-engine/#hostname).
     * @param {Date} [startDate] The start date (inclusive).
     * @param {Date} [endDate] The end date (exclusive).
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [interval] The interval for which the metrics should be aggregated. Time unit is seconds. Default: The interval is set to 15 minutes (900 seconds).
     * @param {string} [aggregateByReporter] Aggregate metrics by reporter.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetricsApi
     */
    public interval(name?: string, reporter?: string, startDate?: Date, endDate?: Date, firstResult?: number, maxResults?: number, interval?: string, aggregateByReporter?: string, options?: any) {
        return MetricsApiFp(this.configuration).interval(name, reporter, startDate, endDate, firstResult, maxResults, interval, aggregateByReporter, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessDefinitionApi - fetch parameter creator
 * @export
 */
export const ProcessDefinitionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProcessDefinition.');
            }
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteProcessDefinitionsByKey.');
            }
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling deleteProcessDefinitionsByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (cascade !== undefined) {
                localVarQueryParameter['cascade'] = cascade;
            }

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityStatistics.');
            }
            const localVarPath = `/process-definition/{id}/statistics`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKey.');
            }
            const localVarPath = `/process-definition/key/{key}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getActivityStatisticsByProcessDefinitionKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/statistics`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeployedStartForm.');
            }
            const localVarPath = `/process-definition/{id}/deployed-start-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getDeployedStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getDeployedStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/deployed-start-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getLatestProcessDefinitionByTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getLatestProcessDefinitionByTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinition.');
            }
            const localVarPath = `/process-definition/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinitionBpmn20Xml.');
            }
            const localVarPath = `/process-definition/{id}/xml`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getProcessDefinitionBpmn20XmlByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/xml`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionByKey.');
            }
            const localVarPath = `/process-definition/key/{key}`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessDefinitionDiagram.');
            }
            const localVarPath = `/process-definition/{id}/diagram`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getProcessDefinitionDiagramByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/diagram`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/process-definition/statistics`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (failedJobs !== undefined) {
                localVarQueryParameter['failedJobs'] = failedJobs;
            }

            if (incidents !== undefined) {
                localVarQueryParameter['incidents'] = incidents;
            }

            if (incidentsForType !== undefined) {
                localVarQueryParameter['incidentsForType'] = incidentsForType;
            }

            if (rootIncidents !== undefined) {
                localVarQueryParameter['rootIncidents'] = rootIncidents;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/process-definition`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any).toISOString();
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any).toISOString();
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/process-definition/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionIdIn !== undefined) {
                localVarQueryParameter['processDefinitionIdIn'] = processDefinitionIdIn;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (deployedAfter !== undefined) {
                localVarQueryParameter['deployedAfter'] = (deployedAfter as any).toISOString();
            }

            if (deployedAt !== undefined) {
                localVarQueryParameter['deployedAt'] = (deployedAt as any).toISOString();
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (keysIn !== undefined) {
                localVarQueryParameter['keysIn'] = keysIn;
            }

            if (keyLike !== undefined) {
                localVarQueryParameter['keyLike'] = keyLike;
            }

            if (category !== undefined) {
                localVarQueryParameter['category'] = category;
            }

            if (categoryLike !== undefined) {
                localVarQueryParameter['categoryLike'] = categoryLike;
            }

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (latestVersion !== undefined) {
                localVarQueryParameter['latestVersion'] = latestVersion;
            }

            if (resourceName !== undefined) {
                localVarQueryParameter['resourceName'] = resourceName;
            }

            if (resourceNameLike !== undefined) {
                localVarQueryParameter['resourceNameLike'] = resourceNameLike;
            }

            if (startableBy !== undefined) {
                localVarQueryParameter['startableBy'] = startableBy;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (includeProcessDefinitionsWithoutTenantId !== undefined) {
                localVarQueryParameter['includeProcessDefinitionsWithoutTenantId'] = includeProcessDefinitionsWithoutTenantId;
            }

            if (versionTag !== undefined) {
                localVarQueryParameter['versionTag'] = versionTag;
            }

            if (versionTagLike !== undefined) {
                localVarQueryParameter['versionTagLike'] = versionTagLike;
            }

            if (withoutVersionTag !== undefined) {
                localVarQueryParameter['withoutVersionTag'] = withoutVersionTag;
            }

            if (startableInTasklist !== undefined) {
                localVarQueryParameter['startableInTasklist'] = startableInTasklist;
            }

            if (notStartableInTasklist !== undefined) {
                localVarQueryParameter['notStartableInTasklist'] = notStartableInTasklist;
            }

            if (startablePermissionCheck !== undefined) {
                localVarQueryParameter['startablePermissionCheck'] = startablePermissionCheck;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRenderedStartForm.');
            }
            const localVarPath = `/process-definition/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRenderedStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getRenderedStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/rendered-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStartForm.');
            }
            const localVarPath = `/process-definition/{id}/startForm`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey(key: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId(key: string, tenantId: string, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getStartFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/startForm`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getStartFormVariables.');
            }
            const localVarPath = `/process-definition/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormVariablesByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling getStartFormVariablesByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/form-variables`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartProcessInstance.');
            }
            const localVarPath = `/process-definition/{id}/restart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestartProcessInstanceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling restartProcessInstanceAsyncOperation.');
            }
            const localVarPath = `/process-definition/{id}/restart-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RestartProcessInstanceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance(id: string, body?: StartProcessInstanceDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling startProcessInstance.');
            }
            const localVarPath = `/process-definition/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling startProcessInstanceByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling startProcessInstanceByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/start`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(id: string, body?: StartProcessInstanceFormDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submitForm.');
            }
            const localVarPath = `/process-definition/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceFormDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling submitFormByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceFormDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling submitFormByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling submitFormByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/submit-form`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"StartProcessInstanceFormDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionId.');
            }
            const localVarPath = `/process-definition/{id}/history-time-to-live`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoryTimeToLiveDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKey.');
            }
            const localVarPath = `/process-definition/key/{key}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoryTimeToLiveDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/history-time-to-live`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"HistoryTimeToLiveDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-definition/suspended`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessDefinitionSuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateProcessDefinitionSuspensionStateById.');
            }
            const localVarPath = `/process-definition/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessDefinitionSuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKey.');
            }
            const localVarPath = `/process-definition/key/{key}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessDefinitionSuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options: any = {}): FetchArgs {
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
            }
            // verify required parameter 'tenantId' is not null or undefined
            if (tenantId === null || tenantId === undefined) {
                throw new RequiredError('tenantId','Required parameter tenantId was null or undefined when calling updateProcessDefinitionSuspensionStateByKeyAndTenantId.');
            }
            const localVarPath = `/process-definition/key/{key}/tenant/{tenant-id}/suspended`
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"tenant-id"}}`, encodeURIComponent(String(tenantId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessDefinitionSuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessDefinitionApi - functional programming interface
 * @export
 */
export const ProcessDefinitionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityStatisticsResultDto>> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityStatisticsResultDto>> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ActivityStatisticsResultDto>> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getDeployedStartForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getDeployedStartFormByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinition(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDiagramDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionBpmn20Xml(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDiagramDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionBpmn20XmlByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDiagramDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessDefinitionDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionDiagram(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionDiagramByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessDefinitionStatisticsResultDto>> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessDefinitionDto>> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getRenderedStartForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getRenderedStartFormByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey(key: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartFormByKey(key, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartFormByKeyAndTenantId(key, tenantId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartFormVariables(id, variableNames, deserializeValues, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).restartProcessInstance(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).restartProcessInstanceAsyncOperation(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceWithVariablesDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).startProcessInstance(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceWithVariablesDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).startProcessInstanceByKey(key, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceWithVariablesDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(id: string, body?: StartProcessInstanceFormDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).submitForm(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).submitFormByKey(key, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProcessInstanceDto> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).submitFormByKeyAndTenantId(key, tenantId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateProcessDefinitionSuspensionState(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateProcessDefinitionSuspensionStateById(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessDefinitionApiFetchParamCreator(configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessDefinitionApi - factory interface
 * @export
 */
export const ProcessDefinitionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a running process instance by id.
         * @summary Delete
         * @param {string} id The id of the process definition to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options)(fetch, basePath);
        },
        /**
         * Deletes process definitions by a given key which belong to no tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options)(fetch, basePath);
        },
        /**
         * Deletes process definitions by a given key and which belong to a tenant id.
         * @summary Delete By Key
         * @param {string} key The key of the process definitions to be deleted.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
         * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
         * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options)(fetch, basePath);
        },
        /**
         * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} id The id of the process definition.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options)(fetch, basePath);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options)(fetch, basePath);
        },
        /**
         * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Activity Instance Statistics
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options)(fetch, basePath);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} id The id of the process definition to get the deployed start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartForm(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getDeployedStartForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getDeployedStartFormByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @summary Get Deployed Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definitions belong to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} id The id of the process definition to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinition(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinition(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20Xml(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20Xml(id, options)(fetch, basePath);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20XmlByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
         * @summary Get XML
         * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
         * @summary Get
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} id The id of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagram(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagram(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagramByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
         * @summary Get Diagram
         * @param {string} key The key of the process definition.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
         * @summary Get Process Instance Statistics
         * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
         * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
         * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options)(fetch, basePath);
        },
        /**
         * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
         * @summary Get List
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
         * @summary Get List Count
         * @param {string} [processDefinitionId] Filter by process definition id.
         * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
         * @param {string} [name] Filter by process definition name.
         * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
         * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
         * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
         * @param {string} [category] Filter by process definition category. Exact match.
         * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
         * @param {number} [version] Filter by process definition version.
         * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
         * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
         * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
         * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
         * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [versionTag] Filter by the version tag.
         * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
         * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
         * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
         * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
         * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options)(fetch, basePath);
        },
        /**
         * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} id The id of the process definition to get the rendered start form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartForm(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getRenderedStartForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getRenderedStartFormByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Get Rendered Start Form
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} id The id of the process definition to get the start form key for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartForm(id: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKey(key: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartFormByKey(key, options)(fetch, basePath);
        },
        /**
         * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
         * @summary Get Start Form Key
         * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartFormByKeyAndTenantId(key, tenantId, options)(fetch, basePath);
        },
        /**
         * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} id The id of the process definition to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartFormVariables(id, variableNames, deserializeValues, options)(fetch, basePath);
        },
        /**
         * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options)(fetch, basePath);
        },
        /**
         * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @summary Get Start Form Variables
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
            return ProcessDefinitionApiFp(configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options)(fetch, basePath);
        },
        /**
         * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).restartProcessInstance(id, body, options)(fetch, basePath);
        },
        /**
         * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
         * @summary Restart Process Instance Async
         * @param {string} id The id of the process definition of the process instances to restart.
         * @param {RestartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).restartProcessInstanceAsyncOperation(id, body, options)(fetch, basePath);
        },
        /**
         * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} id The id of the process definition to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).startProcessInstance(id, body, options)(fetch, basePath);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).startProcessInstanceByKey(key, body, options)(fetch, basePath);
        },
        /**
         * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
         * @summary Start Instance
         * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options)(fetch, basePath);
        },
        /**
         * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} id The id of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitForm(id: string, body?: StartProcessInstanceFormDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).submitForm(id, body, options)(fetch, basePath);
        },
        /**
         * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).submitFormByKey(key, body, options)(fetch, basePath);
        },
        /**
         * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @summary Submit Start Form
         * @param {string} key The key of the process definition to submit the form for.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {StartProcessInstanceFormDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).submitFormByKeyAndTenantId(key, tenantId, body, options)(fetch, basePath);
        },
        /**
         * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} id The id of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options)(fetch, basePath);
        },
        /**
         * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options)(fetch, basePath);
        },
        /**
         * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
         * @summary Update History Time to Live
         * @param {string} key The key of the process definition to change history time to live.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {HistoryTimeToLiveDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends process definitions with the given process definition key.
         * @summary Activate/Suspend By Key
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionState(body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends a given process definition by id.
         * @summary Activate/Suspend By Id
         * @param {string} id The id of the process definition to activate or suspend.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateById(id, body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends a given process definition by the latest version of the process definition for tenant.
         * @summary Activate/Suspend by Id
         * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
         * @param {string} tenantId The id of the tenant the process definition belongs to.
         * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
            return ProcessDefinitionApiFp(configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessDefinitionApi - object-oriented interface
 * @export
 * @class ProcessDefinitionApi
 * @extends {BaseAPI}
 */
export class ProcessDefinitionApi extends BaseAPI {
    /**
     * Deletes a running process instance by id.
     * @summary Delete
     * @param {string} id The id of the process definition to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinition(id: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinition(id, cascade, skipCustomListeners, skipIoMappings, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes process definitions by a given key which belong to no tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinitionsByKey(key: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKey(key, cascade, skipCustomListeners, skipIoMappings, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes process definitions by a given key and which belong to a tenant id.
     * @summary Delete By Key
     * @param {string} key The key of the process definitions to be deleted.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {boolean} [cascade] &#x60;true&#x60;, if all process instances, historic process instances and jobs for this process definition should be deleted.
     * @param {boolean} [skipCustomListeners] &#x60;true&#x60;, if only the built-in ExecutionListeners should be notified with the end event.
     * @param {boolean} [skipIoMappings] A boolean value to control whether input/output mappings should be executed during deletion. &#x60;true&#x60;, if input/output mappings should not be invoked.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public deleteProcessDefinitionsByKeyAndTenantId(key: string, tenantId: string, cascade?: boolean, skipCustomListeners?: boolean, skipIoMappings?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).deleteProcessDefinitionsByKeyAndTenantId(key, tenantId, cascade, skipCustomListeners, skipIoMappings, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves runtime statistics of a given process definition, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} id The id of the process definition.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatistics(id: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatistics(id, failedJobs, incidents, incidentsForType, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves runtime statistics of the latest version of the given process definition which belongs to no tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatisticsByProcessDefinitionKey(key: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKey(key, failedJobs, incidents, incidentsForType, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves runtime statistics of the latest version of the given process definition for a tenant, grouped by activities. These statistics include the number of running activity instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Activity Instance Statistics
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getActivityStatisticsByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getActivityStatisticsByProcessDefinitionKeyAndTenantId(key, tenantId, failedJobs, incidents, incidentsForType, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} id The id of the process definition to get the deployed start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartForm(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartFormByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the deployed form that can be referenced from a start event. For further information please refer to [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @summary Get Deployed Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definitions belong to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getDeployedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getDeployedStartFormByKeyAndTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the latest version of the process definition for tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getLatestProcessDefinitionByTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getLatestProcessDefinitionByTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a process definition according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} id The id of the process definition to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinition(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinition(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20Xml(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20Xml(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20XmlByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves latest version the BPMN 2.0 XML of a process definition. Returns the XML for the latest version of the process definition for tenant.
     * @summary Get XML
     * @param {string} key The key of the process definition (the latest version thereof) whose XML should be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionBpmn20XmlByKeyAndTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionBpmn20XmlByKeyAndTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the latest version of the process definition which belongs to no tenant according to the `ProcessDefinition` interface in the engine.
     * @summary Get
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the diagram of a process definition.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} id The id of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagram(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagram(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the diagram for the latest version of the process definition which belongs to no tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagramByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the diagram for the latest version of the process definition for tenant.  If the process definition's deployment contains an image resource with the same file name as the process definition, the deployed image will be returned by the Get Diagram endpoint. Example: `someProcess.bpmn` and `someProcess.png`. Supported file extentions for the image are: `svg`, `png`, `jpg`, and `gif`.
     * @summary Get Diagram
     * @param {string} key The key of the process definition.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionDiagramByKeyAndTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionDiagramByKeyAndTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves runtime statistics of the process engine, grouped by process definitions. These statistics include the number of running process instances, optionally the number of failed jobs and also optionally the number of incidents either grouped by incident types or for a specific incident type. **Note**: This does not include historic data.
     * @summary Get Process Instance Statistics
     * @param {boolean} [failedJobs] Whether to include the number of failed jobs in the result or not. Valid values are &#x60;true&#x60; or &#x60;false&#x60;.
     * @param {boolean} [incidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60;.
     * @param {string} [incidentsForType] If this property has been set with any incident type (i.e., a string value) the result will only include the number of incidents for the assigned incident type. Cannot be used in combination with &#x60;incidents&#x60;. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {boolean} [rootIncidents] Valid values for this property are &#x60;true&#x60; or &#x60;false&#x60;. If this property has been set to &#x60;true&#x60; the result will include the corresponding number of root incidents for each occurred incident type. If it is set to &#x60;false&#x60;, the incidents will not be included in the result. Cannot be used in combination with &#x60;incidentsForType&#x60; or &#x60;incidents&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionStatistics(failedJobs?: boolean, incidents?: boolean, incidentsForType?: string, rootIncidents?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionStatistics(failedJobs, incidents, incidentsForType, rootIncidents, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for process definitions that fulfill given parameters. Parameters may be the properties of  process definitions, such as the name, key or version. The size of the result set can be retrieved by using the [Get Definition Count](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query-count/) method.
     * @summary Get List
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitions(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitions(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, sortBy, sortOrder, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Requests the number of process definitions that fulfill the query criteria. Takes the same filtering parameters as the [Get Definitions](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/get-query/) method.
     * @summary Get List Count
     * @param {string} [processDefinitionId] Filter by process definition id.
     * @param {string} [processDefinitionIdIn] Filter by a comma-separated list of process definition ids.
     * @param {string} [name] Filter by process definition name.
     * @param {string} [nameLike] Filter by process definition names that the parameter is a substring of.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {Date} [deployedAfter] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed after (exclusive) a specific time. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {Date} [deployedAt] Filter by the deploy time of the deployment the process definition belongs to. Only selects process definitions that have been deployed at a specific time (exact match). By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [key] Filter by process definition key, i.e., the id in the BPMN 2.0 XML. Exact match.
     * @param {string} [keysIn] Filter by a comma-separated list of process definition keys.
     * @param {string} [keyLike] Filter by process definition keys that the parameter is a substring of.
     * @param {string} [category] Filter by process definition category. Exact match.
     * @param {string} [categoryLike] Filter by process definition categories that the parameter is a substring of.
     * @param {number} [version] Filter by process definition version.
     * @param {boolean} [latestVersion] Only include those process definitions that are latest versions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [resourceName] Filter by the name of the process definition resource. Exact match.
     * @param {string} [resourceNameLike] Filter by names of those process definition resources that the parameter is a substring of.
     * @param {string} [startableBy] Filter by a user name who is allowed to start the process.
     * @param {boolean} [active] Only include active process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended process definitions. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process definition must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process definitions which belong to no tenant. Value may only be true, as false is the default behavior.
     * @param {boolean} [includeProcessDefinitionsWithoutTenantId] Include process definitions which belong to no tenant. Can be used in combination with &#x60;tenantIdIn&#x60;. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [versionTag] Filter by the version tag.
     * @param {string} [versionTagLike] Filter by the version tag that the parameter is a substring of.
     * @param {boolean} [withoutVersionTag] Only include process definitions without a &#x60;versionTag&#x60;.
     * @param {boolean} [startableInTasklist] Filter by process definitions which are startable in Tasklist..
     * @param {boolean} [notStartableInTasklist] Filter by process definitions which are not startable in Tasklist.
     * @param {boolean} [startablePermissionCheck] Filter by process definitions which the user is allowed to start in Tasklist. If the user doesn&#x27;t have these permissions the result will be empty list. The permissions are: * &#x60;CREATE&#x60; permission for all Process instances * &#x60;CREATE_INSTANCE&#x60; and &#x60;READ&#x60; permission on Process definition level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getProcessDefinitionsCount(processDefinitionId?: string, processDefinitionIdIn?: string, name?: string, nameLike?: string, deploymentId?: string, deployedAfter?: Date, deployedAt?: Date, key?: string, keysIn?: string, keyLike?: string, category?: string, categoryLike?: string, version?: number, latestVersion?: boolean, resourceName?: string, resourceNameLike?: string, startableBy?: string, active?: boolean, suspended?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, includeProcessDefinitionsWithoutTenantId?: boolean, versionTag?: string, versionTagLike?: string, withoutVersionTag?: boolean, startableInTasklist?: boolean, notStartableInTasklist?: boolean, startablePermissionCheck?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getProcessDefinitionsCount(processDefinitionId, processDefinitionIdIn, name, nameLike, deploymentId, deployedAfter, deployedAt, key, keysIn, keyLike, category, categoryLike, version, latestVersion, resourceName, resourceNameLike, startableBy, active, suspended, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, includeProcessDefinitionsWithoutTenantId, versionTag, versionTagLike, withoutVersionTag, startableInTasklist, notStartableInTasklist, startablePermissionCheck, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the rendered form for a process definition. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} id The id of the process definition to get the rendered start form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartForm(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves  the rendered form for the latest version of the process definition which belongs to no tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartFormByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves  the rendered form for the latest version of the process definition for a tenant. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Get Rendered Start Form
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getRenderedStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getRenderedStartFormByKeyAndTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the key of the start form for a process definition. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} id The id of the process definition to get the start form key for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartForm(id: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the key of the start form for the latest version of the process definition which belongs to no tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormByKey(key: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKey(key, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the key of the start form for the latest version of the process definition for a tenant. The form key corresponds to the `FormData#formKey` property in the engine.
     * @summary Get Start Form Key
     * @param {string} key The key of the process definition (the latest version thereof) for which the form key is to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormByKeyAndTenantId(key: string, tenantId: string, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormByKeyAndTenantId(key, tenantId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the start form variables for a process definition (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} id The id of the process definition to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariables(id, variableNames, deserializeValues, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the start form variables for the latest process definition which belongs to no tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariablesByKey(key: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKey(key, variableNames, deserializeValues, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the start form variables for the latest process definition for a tenant (only if they are defined via the  [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms) approach). The start form variables take form data specified on the start event into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @summary Get Start Form Variables
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note**: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public getStartFormVariablesByKeyAndTenantId(key: string, tenantId: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).getStartFormVariablesByKeyAndTenantId(key, tenantId, variableNames, deserializeValues, options)(this.fetch, this.basePath);
    }

    /**
     * Restarts process instances that were canceled or terminated synchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance Async](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-async/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public restartProcessInstance(id: string, body?: RestartProcessInstanceDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstance(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Restarts process instances that were canceled or terminated asynchronously. Can also restart completed process instances. It will create a new instance using the original instance information. To execute the restart asynchronously, use the [Restart Process Instance](https://docs.camunda.org/manual/7.13/reference/rest/process-definition/post-restart-process-instance-sync/) method.  For more information about the difference between synchronous and asynchronous execution, please refer to the related section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-restart/#execution).
     * @summary Restart Process Instance Async
     * @param {string} id The id of the process definition of the process instances to restart.
     * @param {RestartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public restartProcessInstanceAsyncOperation(id: string, body?: RestartProcessInstanceDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).restartProcessInstanceAsyncOperation(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Instantiates a given process definition. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} id The id of the process definition to be retrieved.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstance(id: string, body?: StartProcessInstanceDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstance(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Instantiates a given process definition, starts the latest version of the process definition which belongs to no tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstanceByKey(key: string, body?: StartProcessInstanceDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKey(key, body, options)(this.fetch, this.basePath);
    }

    /**
     * Instantiates a given process definition, starts the latest version of the process definition for tenant. Process variables and business key may be supplied in the request body.
     * @summary Start Instance
     * @param {string} key The key of the process definition (the latest version thereof) to be retrieved.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public startProcessInstanceByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).startProcessInstanceByKeyAndTenantId(key, tenantId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Starts a process instance using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} id The id of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitForm(id: string, body?: StartProcessInstanceFormDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).submitForm(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Starts the latest version of the process definition which belongs to no tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitFormByKey(key: string, body?: StartProcessInstanceFormDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKey(key, body, options)(this.fetch, this.basePath);
    }

    /**
     * Starts the latest version of the process definition for a tenant using a set of process variables and the business key. If the start event has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See [Documentation on Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @summary Submit Start Form
     * @param {string} key The key of the process definition to submit the form for.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {StartProcessInstanceFormDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public submitFormByKeyAndTenantId(key: string, tenantId: string, body?: StartProcessInstanceFormDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).submitFormByKeyAndTenantId(key, tenantId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates history time to live for process definition. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} id The id of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionId(id: string, body?: HistoryTimeToLiveDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionId(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates history time to live for the latest version of the process definition which belongs to no tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionKey(key: string, body?: HistoryTimeToLiveDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKey(key, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates history time to live for the latest version of the process definition for a tenant. The field is used within [History cleanup](https://docs.camunda.org/manual/7.13/user-guide/process-engine/history/#history-cleanup).
     * @summary Update History Time to Live
     * @param {string} key The key of the process definition to change history time to live.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {HistoryTimeToLiveDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key: string, tenantId: string, body?: HistoryTimeToLiveDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateHistoryTimeToLiveByProcessDefinitionKeyAndTenantId(key, tenantId, body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends process definitions with the given process definition key.
     * @summary Activate/Suspend By Key
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed property is &#x60;processDefinitionId&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionState(body?: ProcessDefinitionSuspensionStateDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionState(body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends a given process definition by id.
     * @summary Activate/Suspend By Id
     * @param {string} id The id of the process definition to activate or suspend.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateById(id: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateById(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends a given process definition by latest version of process definition key which belongs to no tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateByKey(key: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKey(key, body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends a given process definition by the latest version of the process definition for tenant.
     * @summary Activate/Suspend by Id
     * @param {string} key The key of the process definition (the latest version thereof) to be activated/suspended.
     * @param {string} tenantId The id of the tenant the process definition belongs to.
     * @param {ProcessDefinitionSuspensionStateDto} [body] **Note**: Unallowed properties are &#x60;processDefinitionId&#x60; and &#x60;processDefinitionKey&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessDefinitionApi
     */
    public updateProcessDefinitionSuspensionStateByKeyAndTenantId(key: string, tenantId: string, body?: ProcessDefinitionSuspensionStateDto, options?: any) {
        return ProcessDefinitionApiFp(this.configuration).updateProcessDefinitionSuspensionStateByKeyAndTenantId(key, tenantId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * ProcessInstanceApi - fetch parameter creator
 * @export
 */
export const ProcessInstanceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased(body?: DeleteProcessInstancesDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/delete-historic-query-based`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteProcessInstancesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProcessInstance.');
            }
            const localVarPath = `/process-instance/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCustomListeners !== undefined) {
                localVarQueryParameter['skipCustomListeners'] = skipCustomListeners;
            }

            if (skipIoMappings !== undefined) {
                localVarQueryParameter['skipIoMappings'] = skipIoMappings;
            }

            if (skipSubprocesses !== undefined) {
                localVarQueryParameter['skipSubprocesses'] = skipSubprocesses;
            }

            if (failIfNotExists !== undefined) {
                localVarQueryParameter['failIfNotExists'] = failIfNotExists;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteProcessInstanceVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling deleteProcessInstanceVariable.');
            }
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation(body?: DeleteProcessInstancesDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/delete`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"DeleteProcessInstancesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getActivityInstanceTree.');
            }
            const localVarPath = `/process-instance/{id}/activity-instances`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessInstanceVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getProcessInstanceVariable.');
            }
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessInstanceVariableBinary.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getProcessInstanceVariableBinary.');
            }
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables(id: string, deserializeValue?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getProcessInstanceVariables.');
            }
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }

            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }

            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }

            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }

            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceIds !== undefined) {
                localVarQueryParameter['processInstanceIds'] = processInstanceIds;
            }

            if (businessKey !== undefined) {
                localVarQueryParameter['businessKey'] = businessKey;
            }

            if (businessKeyLike !== undefined) {
                localVarQueryParameter['businessKeyLike'] = businessKeyLike;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionKeyNotIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyNotIn'] = processDefinitionKeyNotIn;
            }

            if (deploymentId !== undefined) {
                localVarQueryParameter['deploymentId'] = deploymentId;
            }

            if (superProcessInstance !== undefined) {
                localVarQueryParameter['superProcessInstance'] = superProcessInstance;
            }

            if (subProcessInstance !== undefined) {
                localVarQueryParameter['subProcessInstance'] = subProcessInstance;
            }

            if (superCaseInstance !== undefined) {
                localVarQueryParameter['superCaseInstance'] = superCaseInstance;
            }

            if (subCaseInstance !== undefined) {
                localVarQueryParameter['subCaseInstance'] = subCaseInstance;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (withIncident !== undefined) {
                localVarQueryParameter['withIncident'] = withIncident;
            }

            if (incidentId !== undefined) {
                localVarQueryParameter['incidentId'] = incidentId;
            }

            if (incidentType !== undefined) {
                localVarQueryParameter['incidentType'] = incidentType;
            }

            if (incidentMessage !== undefined) {
                localVarQueryParameter['incidentMessage'] = incidentMessage;
            }

            if (incidentMessageLike !== undefined) {
                localVarQueryParameter['incidentMessageLike'] = incidentMessageLike;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (processDefinitionWithoutTenantId !== undefined) {
                localVarQueryParameter['processDefinitionWithoutTenantId'] = processDefinitionWithoutTenantId;
            }

            if (activityIdIn !== undefined) {
                localVarQueryParameter['activityIdIn'] = activityIdIn;
            }

            if (rootProcessInstances !== undefined) {
                localVarQueryParameter['rootProcessInstances'] = rootProcessInstances;
            }

            if (leafProcessInstances !== undefined) {
                localVarQueryParameter['leafProcessInstances'] = leafProcessInstances;
            }

            if (variables !== undefined) {
                localVarQueryParameter['variables'] = variables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance(id: string, body?: ProcessInstanceModificationDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyProcessInstance.');
            }
            const localVarPath = `/process-instance/{id}/modification`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceModificationDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation(id: string, body?: ProcessInstanceModificationDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyProcessInstanceAsyncOperation.');
            }
            const localVarPath = `/process-instance/{id}/modification-async`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceModificationDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables(id: string, body?: PatchVariablesDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyProcessInstanceVariables.');
            }
            const localVarPath = `/process-instance/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchVariablesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances(body?: ProcessInstanceQueryDto, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount(body?: ProcessInstanceQueryDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable(id: string, varName: string, body?: VariableValueDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setProcessInstanceVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling setProcessInstanceVariable.');
            }
            const localVarPath = `/process-instance/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VariableValueDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary(id: string, varName: string, data?: Blob, valueType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setProcessInstanceVariableBinary.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling setProcessInstanceVariableBinary.');
            }
            const localVarPath = `/process-instance/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (data !== undefined) {
                localVarFormParams.set('data', data as any);
            }

            if (valueType !== undefined) {
                localVarFormParams.set('valueType', valueType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess(body?: SetJobRetriesByProcessDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/job-retries`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetJobRetriesByProcessDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased(body?: SetJobRetriesByProcessDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/job-retries-historic-query-based`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SetJobRetriesByProcessDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState(body?: ProcessInstanceSuspensionStateDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/suspended`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceSuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation(body?: ProcessInstanceSuspensionStateAsyncDto, options: any = {}): FetchArgs {
            const localVarPath = `/process-instance/suspended-async`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProcessInstanceSuspensionStateAsyncDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById(id: string, body?: SuspensionStateDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSuspensionStateById.');
            }
            const localVarPath = `/process-instance/{id}/suspended`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SuspensionStateDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProcessInstanceApi - functional programming interface
 * @export
 */
export const ProcessInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased(body?: DeleteProcessInstancesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).deleteAsyncHistoricQueryBased(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).deleteProcessInstanceVariable(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation(body?: DeleteProcessInstancesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).deleteProcessInstancesAsyncOperation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ActivityInstanceDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getActivityInstanceTree(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VariableValueDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getProcessInstanceVariable(id, varName, deserializeValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getProcessInstanceVariableBinary(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getProcessInstanceVariables(id, deserializeValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessInstanceDto>> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance(id: string, body?: ProcessInstanceModificationDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).modifyProcessInstance(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation(id: string, body?: ProcessInstanceModificationDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).modifyProcessInstanceAsyncOperation(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables(id: string, body?: PatchVariablesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).modifyProcessInstanceVariables(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances(body?: ProcessInstanceQueryDto, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<ProcessInstanceDto>> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).queryProcessInstances(body, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount(body?: ProcessInstanceQueryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).queryProcessInstancesCount(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable(id: string, varName: string, body?: VariableValueDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).setProcessInstanceVariable(id, varName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary(id: string, varName: string, data?: Blob, valueType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).setProcessInstanceVariableBinary(id, varName, data, valueType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess(body?: SetJobRetriesByProcessDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).setRetriesByProcess(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased(body?: SetJobRetriesByProcessDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).setRetriesByProcessHistoricQueryBased(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState(body?: ProcessInstanceSuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).updateSuspensionState(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation(body?: ProcessInstanceSuspensionStateAsyncDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<BatchDto> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).updateSuspensionStateAsyncOperation(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById(id: string, body?: SuspensionStateDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProcessInstanceApiFetchParamCreator(configuration).updateSuspensionStateById(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProcessInstanceApi - factory interface
 * @export
 */
export const ProcessInstanceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsyncHistoricQueryBased(body?: DeleteProcessInstancesDto, options?: any) {
            return ProcessInstanceApiFp(configuration).deleteAsyncHistoricQueryBased(body, options)(fetch, basePath);
        },
        /**
         * Deletes a running process instance by id.
         * @param {string} id The id of the process instance to be deleted.
         * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
         * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
         * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
         * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: any) {
            return ProcessInstanceApiFp(configuration).deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options)(fetch, basePath);
        },
        /**
         * Deletes a variable of a process instance by id.
         * @param {string} id The id of the process instance to delete the variable from.
         * @param {string} varName The name of the variable to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstanceVariable(id: string, varName: string, options?: any) {
            return ProcessInstanceApiFp(configuration).deleteProcessInstanceVariable(id, varName, options)(fetch, basePath);
        },
        /**
         * Deletes multiple process instances asynchronously (batch).
         * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProcessInstancesAsyncOperation(body?: DeleteProcessInstancesDto, options?: any) {
            return ProcessInstanceApiFp(configuration).deleteProcessInstancesAsyncOperation(body, options)(fetch, basePath);
        },
        /**
         * Retrieves an Activity Instance (Tree) for a given process instance by id.
         * @param {string} id The id of the process instance for which the activity instance should be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getActivityInstanceTree(id: string, options?: any) {
            return ProcessInstanceApiFp(configuration).getActivityInstanceTree(id, options)(fetch, basePath);
        },
        /**
         * Retrieves a variable of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
            return ProcessInstanceApiFp(configuration).getProcessInstanceVariable(id, varName, deserializeValue, options)(fetch, basePath);
        },
        /**
         * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariableBinary(id: string, varName: string, options?: any) {
            return ProcessInstanceApiFp(configuration).getProcessInstanceVariableBinary(id, varName, options)(fetch, basePath);
        },
        /**
         * Retrieves all variables of a given process instance by id.
         * @param {string} id The id of the process instance to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: any) {
            return ProcessInstanceApiFp(configuration).getProcessInstanceVariables(id, deserializeValue, options)(fetch, basePath);
        },
        /**
         * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any) {
            return ProcessInstanceApiFp(configuration).getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options)(fetch, basePath);
        },
        /**
         * Queries for the number of process instances that fulfill given parameters.
         * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
         * @param {string} [businessKey] Filter by process instance business key.
         * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
         * @param {string} [caseInstanceId] Filter by case instance id.
         * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
         * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
         * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
         * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
         * @param {string} [deploymentId] Filter by the deployment the id belongs to.
         * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
         * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
         * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
         * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
         * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
         * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
         * @param {string} [incidentId] Filter by the incident id.
         * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
         * @param {string} [incidentMessage] Filter by the incident message. Exact match.
         * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
         * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
         * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
         * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
         * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
         * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
         * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
         * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any) {
            return ProcessInstanceApiFp(configuration).getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options)(fetch, basePath);
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstance(id: string, body?: ProcessInstanceModificationDto, options?: any) {
            return ProcessInstanceApiFp(configuration).modifyProcessInstance(id, body, options)(fetch, basePath);
        },
        /**
         * Submits a list of modification instructions to change a process instance's execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
         * @param {string} id The id of the process instance to modify.
         * @param {ProcessInstanceModificationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceAsyncOperation(id: string, body?: ProcessInstanceModificationDto, options?: any) {
            return ProcessInstanceApiFp(configuration).modifyProcessInstanceAsyncOperation(id, body, options)(fetch, basePath);
        },
        /**
         * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the process instance to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyProcessInstanceVariables(id: string, body?: PatchVariablesDto, options?: any) {
            return ProcessInstanceApiFp(configuration).modifyProcessInstanceVariables(id, body, options)(fetch, basePath);
        },
        /**
         * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstances(body?: ProcessInstanceQueryDto, firstResult?: number, maxResults?: number, options?: any) {
            return ProcessInstanceApiFp(configuration).queryProcessInstances(body, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
         * @param {ProcessInstanceQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryProcessInstancesCount(body?: ProcessInstanceQueryDto, options?: any) {
            return ProcessInstanceApiFp(configuration).queryProcessInstancesCount(body, options)(fetch, basePath);
        },
        /**
         * Sets a variable of a given process instance by id.
         * @param {string} id The id of the process instance to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
            return ProcessInstanceApiFp(configuration).setProcessInstanceVariable(id, varName, body, options)(fetch, basePath);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the process instance to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProcessInstanceVariableBinary(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
            return ProcessInstanceApiFp(configuration).setProcessInstanceVariableBinary(id, varName, data, valueType, options)(fetch, basePath);
        },
        /**
         * Create a batch to set retries of jobs associated with given processes asynchronously.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcess(body?: SetJobRetriesByProcessDto, options?: any) {
            return ProcessInstanceApiFp(configuration).setRetriesByProcess(body, options)(fetch, basePath);
        },
        /**
         * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
         * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setRetriesByProcessHistoricQueryBased(body?: SetJobRetriesByProcessDto, options?: any) {
            return ProcessInstanceApiFp(configuration).setRetriesByProcessHistoricQueryBased(body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
         * @param {ProcessInstanceSuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionState(body?: ProcessInstanceSuspensionStateDto, options?: any) {
            return ProcessInstanceApiFp(configuration).updateSuspensionState(body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
         * @param {ProcessInstanceSuspensionStateAsyncDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateAsyncOperation(body?: ProcessInstanceSuspensionStateAsyncDto, options?: any) {
            return ProcessInstanceApiFp(configuration).updateSuspensionStateAsyncOperation(body, options)(fetch, basePath);
        },
        /**
         * Activates or suspends a given process instance by id.
         * @param {string} id The id of the process instance to activate or suspend.
         * @param {SuspensionStateDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSuspensionStateById(id: string, body?: SuspensionStateDto, options?: any) {
            return ProcessInstanceApiFp(configuration).updateSuspensionStateById(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * ProcessInstanceApi - object-oriented interface
 * @export
 * @class ProcessInstanceApi
 * @extends {BaseAPI}
 */
export class ProcessInstanceApi extends BaseAPI {
    /**
     * Deletes a set of process instances asynchronously (batch) based on a historic process instance query.
     * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteAsyncHistoricQueryBased(body?: DeleteProcessInstancesDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).deleteAsyncHistoricQueryBased(body, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a running process instance by id.
     * @param {string} id The id of the process instance to be deleted.
     * @param {boolean} [skipCustomListeners] If set to true, the custom listeners will be skipped.
     * @param {boolean} [skipIoMappings] If set to true, the input/output mappings will be skipped.
     * @param {boolean} [skipSubprocesses] If set to true, subprocesses related to deleted processes will be skipped.
     * @param {boolean} [failIfNotExists] If set to false, the request will still be successful if the process id is not found.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstance(id: string, skipCustomListeners?: boolean, skipIoMappings?: boolean, skipSubprocesses?: boolean, failIfNotExists?: boolean, options?: any) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstance(id, skipCustomListeners, skipIoMappings, skipSubprocesses, failIfNotExists, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a variable of a process instance by id.
     * @param {string} id The id of the process instance to delete the variable from.
     * @param {string} varName The name of the variable to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstanceVariable(id: string, varName: string, options?: any) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstanceVariable(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Deletes multiple process instances asynchronously (batch).
     * @param {DeleteProcessInstancesDto} [body] **Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public deleteProcessInstancesAsyncOperation(body?: DeleteProcessInstancesDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).deleteProcessInstancesAsyncOperation(body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves an Activity Instance (Tree) for a given process instance by id.
     * @param {string} id The id of the process instance for which the activity instance should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getActivityInstanceTree(id: string, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getActivityInstanceTree(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a variable of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariable(id, varName, deserializeValue, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the content of a Process Variable by the Process Instance id and the Process Variable name. Applicable for byte array or file Process Variables.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariableBinary(id: string, varName: string, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariableBinary(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves all variables of a given process instance by id.
     * @param {string} id The id of the process instance to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstanceVariables(id: string, deserializeValue?: boolean, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstanceVariables(id, deserializeValue, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for process instances that fulfill given parameters. Parameters may be static as well as dynamic runtime properties of process instances. The size of the result set can be retrieved by using the Get Instance Count method.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstances(sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstances(sortBy, sortOrder, firstResult, maxResults, processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of process instances that fulfill given parameters.
     * @param {string} [processInstanceIds] Filter by a comma-separated list of process instance ids.
     * @param {string} [businessKey] Filter by process instance business key.
     * @param {string} [businessKeyLike] Filter by process instance business key that the parameter is a substring of.
     * @param {string} [caseInstanceId] Filter by case instance id.
     * @param {string} [processDefinitionId] Filter by the deployment the id belongs to.
     * @param {string} [processDefinitionKey] Filter by the key of the process definition the instances run on.
     * @param {string} [processDefinitionKeyIn] Filter by a comma-separated list of process definition keys. A process instance must have one of the given process definition keys.
     * @param {string} [processDefinitionKeyNotIn] Exclude instances by a comma-separated list of process definition keys. A process instance must not have one of the given process definition keys.
     * @param {string} [deploymentId] Filter by the deployment the id belongs to.
     * @param {string} [superProcessInstance] Restrict query to all process instances that are sub process instances of the given process instance. Takes a process instance id.
     * @param {string} [subProcessInstance] Restrict query to all process instances that have the given process instance as a sub process instance. Takes a process instance id.
     * @param {string} [superCaseInstance] Restrict query to all process instances that are sub process instances of the given case instance. Takes a case instance id.
     * @param {string} [subCaseInstance] Restrict query to all process instances that have the given case instance as a sub case instance. Takes a case instance id.
     * @param {boolean} [active] Only include active process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [suspended] Only include suspended process instances. Value may only be true, as false is the default behavior.
     * @param {boolean} [withIncident] Filter by presence of incidents. Selects only process instances that have an incident.
     * @param {string} [incidentId] Filter by the incident id.
     * @param {string} [incidentType] Filter by the incident type. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/incidents/#incident-types) for a list of incident types.
     * @param {string} [incidentMessage] Filter by the incident message. Exact match.
     * @param {string} [incidentMessageLike] Filter by the incident message that the parameter is a substring of.
     * @param {string} [tenantIdIn] Filter by a comma-separated list of tenant ids. A process instance must have one of the given tenant ids.
     * @param {boolean} [withoutTenantId] Only include process instances which belong to no tenant.
     * @param {boolean} [processDefinitionWithoutTenantId] Only include process instances which process definition has no tenant id.
     * @param {string} [activityIdIn] Filter by a comma-separated list of activity ids. A process instance must currently wait in a leaf activity with one of the given activity ids.
     * @param {boolean} [rootProcessInstances] Restrict the query to all process instances that are top level process instances.
     * @param {boolean} [leafProcessInstances] Restrict the query to all process instances that are leaf instances. (i.e. don&#x27;t have any sub instances).
     * @param {string} [variables] Only include process instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set to true variableName and variablename are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set to true variableValue and variablevalue are treated as equal.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public getProcessInstancesCount(processInstanceIds?: string, businessKey?: string, businessKeyLike?: string, caseInstanceId?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionKeyNotIn?: string, deploymentId?: string, superProcessInstance?: string, subProcessInstance?: string, superCaseInstance?: string, subCaseInstance?: string, active?: boolean, suspended?: boolean, withIncident?: boolean, incidentId?: string, incidentType?: string, incidentMessage?: string, incidentMessageLike?: string, tenantIdIn?: string, withoutTenantId?: boolean, processDefinitionWithoutTenantId?: boolean, activityIdIn?: string, rootProcessInstances?: boolean, leafProcessInstances?: boolean, variables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, options?: any) {
        return ProcessInstanceApiFp(this.configuration).getProcessInstancesCount(processInstanceIds, businessKey, businessKeyLike, caseInstanceId, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionKeyNotIn, deploymentId, superProcessInstance, subProcessInstance, superCaseInstance, subCaseInstance, active, suspended, withIncident, incidentId, incidentType, incidentMessage, incidentMessageLike, tenantIdIn, withoutTenantId, processDefinitionWithoutTenantId, activityIdIn, rootProcessInstances, leafProcessInstances, variables, variableNamesIgnoreCase, variableValuesIgnoreCase, options)(this.fetch, this.basePath);
    }

    /**
     * Submits a list of modification instructions to change a process instance's execution state. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Canceling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed immediately and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/develop/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstance(id: string, body?: ProcessInstanceModificationDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstance(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Submits a list of modification instructions to change a process instance's execution state async. A modification instruction is one of the following:  * Starting execution before an activity * Starting execution after an activity on its single outgoing sequence flow * Starting execution on a specific sequence flow * Cancelling an activity instance, transition instance, or all instances (activity or transition) for an activity  Instructions are executed asynchronous and in the order they are provided in this request's body. Variables can be provided with every starting instruction.  The exact semantics of modification can be read about in the [User guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/process-instance-modification/).
     * @param {string} id The id of the process instance to modify.
     * @param {ProcessInstanceModificationDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstanceAsyncOperation(id: string, body?: ProcessInstanceModificationDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstanceAsyncOperation(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates or deletes the variables of a process instance by id. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the process instance to set variables for.
     * @param {PatchVariablesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public modifyProcessInstanceVariables(id: string, body?: PatchVariablesDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).modifyProcessInstanceVariables(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for process instances that fulfill given parameters through a JSON object. This method is slightly more powerful than the Get Instances method because it allows filtering by multiple process variables of types `string`, `number` or `boolean`.
     * @param {ProcessInstanceQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public queryProcessInstances(body?: ProcessInstanceQueryDto, firstResult?: number, maxResults?: number, options?: any) {
        return ProcessInstanceApiFp(this.configuration).queryProcessInstances(body, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for the number of process instances that fulfill the given parameters. This method takes the same message body as the Get Instances (POST) method and therefore it is slightly more powerful than the Get Instance Count method.
     * @param {ProcessInstanceQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public queryProcessInstancesCount(body?: ProcessInstanceQueryDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).queryProcessInstancesCount(body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets a variable of a given process instance by id.
     * @param {string} id The id of the process instance to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setProcessInstanceVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).setProcessInstanceVariable(id, varName, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the process instance to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {Blob} [data] 
     * @param {string} [valueType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setProcessInstanceVariableBinary(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
        return ProcessInstanceApiFp(this.configuration).setProcessInstanceVariableBinary(id, varName, data, valueType, options)(this.fetch, this.basePath);
    }

    /**
     * Create a batch to set retries of jobs associated with given processes asynchronously.
     * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and processInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;historicProcessInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setRetriesByProcess(body?: SetJobRetriesByProcessDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).setRetriesByProcess(body, options)(this.fetch, this.basePath);
    }

    /**
     * Create a batch to set retries of jobs asynchronously based on a historic process instance query.
     * @param {SetJobRetriesByProcessDto} [body] Please note that if both processInstances and historicProcessInstanceQuery are provided,
then the resulting execution will be performed on the union of these sets.
**Unallowed property**: &#x60;processInstanceQuery&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public setRetriesByProcessHistoricQueryBased(body?: SetJobRetriesByProcessDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).setRetriesByProcessHistoricQueryBased(body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends process instances by providing certain criteria:  # Activate/Suspend Process Instance By Process Definition Id * `suspend` * `processDefinitionId`  # Activate/Suspend Process Instance By Process Definition Key  * `suspend` * `processDefinitionKey` * `processDefinitionTenantId` * `processDefinitionWithoutTenantId`  # Activate/Suspend Process Instance In Group * `suspend` * `processInstanceIds` * `processInstanceQuery` * `historicProcessInstanceQuery`
     * @param {ProcessInstanceSuspensionStateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionState(body?: ProcessInstanceSuspensionStateDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionState(body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends process instances asynchronously with a list of process instance ids, a process instance query, and/or a historical process instance query.
     * @param {ProcessInstanceSuspensionStateAsyncDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionStateAsyncOperation(body?: ProcessInstanceSuspensionStateAsyncDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionStateAsyncOperation(body, options)(this.fetch, this.basePath);
    }

    /**
     * Activates or suspends a given process instance by id.
     * @param {string} id The id of the process instance to activate or suspend.
     * @param {SuspensionStateDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProcessInstanceApi
     */
    public updateSuspensionStateById(id: string, body?: SuspensionStateDto, options?: any) {
        return ProcessInstanceApiFp(this.configuration).updateSuspensionStateById(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * SchemaLogApi - fetch parameter creator
 * @export
 */
export const SchemaLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/schema/log`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {SchemaLogQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog(body?: SchemaLogQueryDto, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/schema/log`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SchemaLogQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SchemaLogApi - functional programming interface
 * @export
 */
export const SchemaLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SchemaLogEntryDto>> {
            const localVarFetchArgs = SchemaLogApiFetchParamCreator(configuration).getSchemaLog(version, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {SchemaLogQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog(body?: SchemaLogQueryDto, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<SchemaLogEntryDto>> {
            const localVarFetchArgs = SchemaLogApiFetchParamCreator(configuration).querySchemaLog(body, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SchemaLogApi - factory interface
 * @export
 */
export const SchemaLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {string} [version] Only return schema log entries with a specific version.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: any) {
            return SchemaLogApiFp(configuration).getSchemaLog(version, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Queries for schema log entries that fulfill given parameters.
         * @param {SchemaLogQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        querySchemaLog(body?: SchemaLogQueryDto, firstResult?: number, maxResults?: number, options?: any) {
            return SchemaLogApiFp(configuration).querySchemaLog(body, firstResult, maxResults, options)(fetch, basePath);
        },
    };
};

/**
 * SchemaLogApi - object-oriented interface
 * @export
 * @class SchemaLogApi
 * @extends {BaseAPI}
 */
export class SchemaLogApi extends BaseAPI {
    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {string} [version] Only return schema log entries with a specific version.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    public getSchemaLog(version?: string, firstResult?: number, maxResults?: number, options?: any) {
        return SchemaLogApiFp(this.configuration).getSchemaLog(version, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for schema log entries that fulfill given parameters.
     * @param {SchemaLogQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SchemaLogApi
     */
    public querySchemaLog(body?: SchemaLogQueryDto, firstResult?: number, maxResults?: number, options?: any) {
        return SchemaLogApiFp(this.configuration).querySchemaLog(body, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

}
/**
 * SignalApi - fetch parameter creator
 * @export
 */
export const SignalApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine's signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal(body?: SignalDto, options: any = {}): FetchArgs {
            const localVarPath = `/signal`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"SignalDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SignalApi - functional programming interface
 * @export
 */
export const SignalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine's signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal(body?: SignalDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SignalApiFetchParamCreator(configuration).throwSignal(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SignalApi - factory interface
 * @export
 */
export const SignalApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine's signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
         * @param {SignalDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        throwSignal(body?: SignalDto, options?: any) {
            return SignalApiFp(configuration).throwSignal(body, options)(fetch, basePath);
        },
    };
};

/**
 * SignalApi - object-oriented interface
 * @export
 * @class SignalApi
 * @extends {BaseAPI}
 */
export class SignalApi extends BaseAPI {
    /**
     * A signal is an event of global scope (broadcast semantics) and is delivered to all active handlers. Internally this maps to the engine's signal event received builder method `RuntimeService#createSignalEvent()`. For more information about the signal behavior, see the [Signal Events](https://docs.camunda.org/manual/7.13/reference/bpmn20/events/signal-events/) section of the [BPMN 2.0 Implementation Reference](https://docs.camunda.org/manual/7.13/reference/bpmn20/).
     * @param {SignalDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SignalApi
     */
    public throwSignal(body?: SignalDto, options?: any) {
        return SignalApiFp(this.configuration).throwSignal(body, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskApi - fetch parameter creator
 * @export
 */
export const TaskApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(id: string, body?: UserIdDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling claim.');
            }
            const localVarPath = `/task/{id}/claim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserIdDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(id: string, body?: CompleteTaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling complete.');
            }
            const localVarPath = `/task/{id}/complete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompleteTaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(body?: TaskDto, options: any = {}): FetchArgs {
            const localVarPath = `/task/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask(id: string, body?: UserIdDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling delegateTask.');
            }
            const localVarPath = `/task/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserIdDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDeployedForm.');
            }
            const localVarPath = `/task/{id}/deployed-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getForm.');
            }
            const localVarPath = `/task/{id}/form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getFormVariables.');
            }
            const localVarPath = `/task/{id}/form-variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (variableNames !== undefined) {
                localVarQueryParameter['variableNames'] = variableNames;
            }

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getRenderedForm.');
            }
            const localVarPath = `/task/{id}/rendered-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options: any = {}): FetchArgs {
            const localVarPath = `/task/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (processInstanceId !== undefined) {
                localVarQueryParameter['processInstanceId'] = processInstanceId;
            }

            if (processInstanceIdIn !== undefined) {
                localVarQueryParameter['processInstanceIdIn'] = processInstanceIdIn;
            }

            if (processInstanceBusinessKey !== undefined) {
                localVarQueryParameter['processInstanceBusinessKey'] = processInstanceBusinessKey;
            }

            if (processInstanceBusinessKeyExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyExpression'] = processInstanceBusinessKeyExpression;
            }

            if (processInstanceBusinessKeyIn !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyIn'] = processInstanceBusinessKeyIn;
            }

            if (processInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLike'] = processInstanceBusinessKeyLike;
            }

            if (processInstanceBusinessKeyLikeExpression !== undefined) {
                localVarQueryParameter['processInstanceBusinessKeyLikeExpression'] = processInstanceBusinessKeyLikeExpression;
            }

            if (processDefinitionId !== undefined) {
                localVarQueryParameter['processDefinitionId'] = processDefinitionId;
            }

            if (processDefinitionKey !== undefined) {
                localVarQueryParameter['processDefinitionKey'] = processDefinitionKey;
            }

            if (processDefinitionKeyIn !== undefined) {
                localVarQueryParameter['processDefinitionKeyIn'] = processDefinitionKeyIn;
            }

            if (processDefinitionName !== undefined) {
                localVarQueryParameter['processDefinitionName'] = processDefinitionName;
            }

            if (processDefinitionNameLike !== undefined) {
                localVarQueryParameter['processDefinitionNameLike'] = processDefinitionNameLike;
            }

            if (executionId !== undefined) {
                localVarQueryParameter['executionId'] = executionId;
            }

            if (caseInstanceId !== undefined) {
                localVarQueryParameter['caseInstanceId'] = caseInstanceId;
            }

            if (caseInstanceBusinessKey !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKey'] = caseInstanceBusinessKey;
            }

            if (caseInstanceBusinessKeyLike !== undefined) {
                localVarQueryParameter['caseInstanceBusinessKeyLike'] = caseInstanceBusinessKeyLike;
            }

            if (caseDefinitionId !== undefined) {
                localVarQueryParameter['caseDefinitionId'] = caseDefinitionId;
            }

            if (caseDefinitionKey !== undefined) {
                localVarQueryParameter['caseDefinitionKey'] = caseDefinitionKey;
            }

            if (caseDefinitionName !== undefined) {
                localVarQueryParameter['caseDefinitionName'] = caseDefinitionName;
            }

            if (caseDefinitionNameLike !== undefined) {
                localVarQueryParameter['caseDefinitionNameLike'] = caseDefinitionNameLike;
            }

            if (caseExecutionId !== undefined) {
                localVarQueryParameter['caseExecutionId'] = caseExecutionId;
            }

            if (activityInstanceIdIn !== undefined) {
                localVarQueryParameter['activityInstanceIdIn'] = activityInstanceIdIn;
            }

            if (tenantIdIn !== undefined) {
                localVarQueryParameter['tenantIdIn'] = tenantIdIn;
            }

            if (withoutTenantId !== undefined) {
                localVarQueryParameter['withoutTenantId'] = withoutTenantId;
            }

            if (assignee !== undefined) {
                localVarQueryParameter['assignee'] = assignee;
            }

            if (assigneeExpression !== undefined) {
                localVarQueryParameter['assigneeExpression'] = assigneeExpression;
            }

            if (assigneeLike !== undefined) {
                localVarQueryParameter['assigneeLike'] = assigneeLike;
            }

            if (assigneeLikeExpression !== undefined) {
                localVarQueryParameter['assigneeLikeExpression'] = assigneeLikeExpression;
            }

            if (assigneeIn !== undefined) {
                localVarQueryParameter['assigneeIn'] = assigneeIn;
            }

            if (owner !== undefined) {
                localVarQueryParameter['owner'] = owner;
            }

            if (ownerExpression !== undefined) {
                localVarQueryParameter['ownerExpression'] = ownerExpression;
            }

            if (candidateGroup !== undefined) {
                localVarQueryParameter['candidateGroup'] = candidateGroup;
            }

            if (candidateGroupExpression !== undefined) {
                localVarQueryParameter['candidateGroupExpression'] = candidateGroupExpression;
            }

            if (candidateUser !== undefined) {
                localVarQueryParameter['candidateUser'] = candidateUser;
            }

            if (candidateUserExpression !== undefined) {
                localVarQueryParameter['candidateUserExpression'] = candidateUserExpression;
            }

            if (includeAssignedTasks !== undefined) {
                localVarQueryParameter['includeAssignedTasks'] = includeAssignedTasks;
            }

            if (involvedUser !== undefined) {
                localVarQueryParameter['involvedUser'] = involvedUser;
            }

            if (involvedUserExpression !== undefined) {
                localVarQueryParameter['involvedUserExpression'] = involvedUserExpression;
            }

            if (assigned !== undefined) {
                localVarQueryParameter['assigned'] = assigned;
            }

            if (unassigned !== undefined) {
                localVarQueryParameter['unassigned'] = unassigned;
            }

            if (taskDefinitionKey !== undefined) {
                localVarQueryParameter['taskDefinitionKey'] = taskDefinitionKey;
            }

            if (taskDefinitionKeyIn !== undefined) {
                localVarQueryParameter['taskDefinitionKeyIn'] = taskDefinitionKeyIn;
            }

            if (taskDefinitionKeyLike !== undefined) {
                localVarQueryParameter['taskDefinitionKeyLike'] = taskDefinitionKeyLike;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (nameNotEqual !== undefined) {
                localVarQueryParameter['nameNotEqual'] = nameNotEqual;
            }

            if (nameLike !== undefined) {
                localVarQueryParameter['nameLike'] = nameLike;
            }

            if (nameNotLike !== undefined) {
                localVarQueryParameter['nameNotLike'] = nameNotLike;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (descriptionLike !== undefined) {
                localVarQueryParameter['descriptionLike'] = descriptionLike;
            }

            if (priority !== undefined) {
                localVarQueryParameter['priority'] = priority;
            }

            if (maxPriority !== undefined) {
                localVarQueryParameter['maxPriority'] = maxPriority;
            }

            if (minPriority !== undefined) {
                localVarQueryParameter['minPriority'] = minPriority;
            }

            if (dueDate !== undefined) {
                localVarQueryParameter['dueDate'] = dueDate;
            }

            if (dueDateExpression !== undefined) {
                localVarQueryParameter['dueDateExpression'] = dueDateExpression;
            }

            if (dueAfter !== undefined) {
                localVarQueryParameter['dueAfter'] = dueAfter;
            }

            if (dueAfterExpression !== undefined) {
                localVarQueryParameter['dueAfterExpression'] = dueAfterExpression;
            }

            if (dueBefore !== undefined) {
                localVarQueryParameter['dueBefore'] = dueBefore;
            }

            if (dueBeforeExpression !== undefined) {
                localVarQueryParameter['dueBeforeExpression'] = dueBeforeExpression;
            }

            if (followUpDate !== undefined) {
                localVarQueryParameter['followUpDate'] = followUpDate;
            }

            if (followUpDateExpression !== undefined) {
                localVarQueryParameter['followUpDateExpression'] = followUpDateExpression;
            }

            if (followUpAfter !== undefined) {
                localVarQueryParameter['followUpAfter'] = followUpAfter;
            }

            if (followUpAfterExpression !== undefined) {
                localVarQueryParameter['followUpAfterExpression'] = followUpAfterExpression;
            }

            if (followUpBefore !== undefined) {
                localVarQueryParameter['followUpBefore'] = followUpBefore;
            }

            if (followUpBeforeExpression !== undefined) {
                localVarQueryParameter['followUpBeforeExpression'] = followUpBeforeExpression;
            }

            if (followUpBeforeOrNotExistent !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistent'] = followUpBeforeOrNotExistent;
            }

            if (followUpBeforeOrNotExistentExpression !== undefined) {
                localVarQueryParameter['followUpBeforeOrNotExistentExpression'] = followUpBeforeOrNotExistentExpression;
            }

            if (createdOn !== undefined) {
                localVarQueryParameter['createdOn'] = createdOn;
            }

            if (createdOnExpression !== undefined) {
                localVarQueryParameter['createdOnExpression'] = createdOnExpression;
            }

            if (createdAfter !== undefined) {
                localVarQueryParameter['createdAfter'] = createdAfter;
            }

            if (createdAfterExpression !== undefined) {
                localVarQueryParameter['createdAfterExpression'] = createdAfterExpression;
            }

            if (createdBefore !== undefined) {
                localVarQueryParameter['createdBefore'] = createdBefore;
            }

            if (createdBeforeExpression !== undefined) {
                localVarQueryParameter['createdBeforeExpression'] = createdBeforeExpression;
            }

            if (delegationState !== undefined) {
                localVarQueryParameter['delegationState'] = delegationState;
            }

            if (candidateGroups !== undefined) {
                localVarQueryParameter['candidateGroups'] = candidateGroups;
            }

            if (candidateGroupsExpression !== undefined) {
                localVarQueryParameter['candidateGroupsExpression'] = candidateGroupsExpression;
            }

            if (withCandidateGroups !== undefined) {
                localVarQueryParameter['withCandidateGroups'] = withCandidateGroups;
            }

            if (withoutCandidateGroups !== undefined) {
                localVarQueryParameter['withoutCandidateGroups'] = withoutCandidateGroups;
            }

            if (withCandidateUsers !== undefined) {
                localVarQueryParameter['withCandidateUsers'] = withCandidateUsers;
            }

            if (withoutCandidateUsers !== undefined) {
                localVarQueryParameter['withoutCandidateUsers'] = withoutCandidateUsers;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (suspended !== undefined) {
                localVarQueryParameter['suspended'] = suspended;
            }

            if (taskVariables !== undefined) {
                localVarQueryParameter['taskVariables'] = taskVariables;
            }

            if (processVariables !== undefined) {
                localVarQueryParameter['processVariables'] = processVariables;
            }

            if (caseInstanceVariables !== undefined) {
                localVarQueryParameter['caseInstanceVariables'] = caseInstanceVariables;
            }

            if (variableNamesIgnoreCase !== undefined) {
                localVarQueryParameter['variableNamesIgnoreCase'] = variableNamesIgnoreCase;
            }

            if (variableValuesIgnoreCase !== undefined) {
                localVarQueryParameter['variableValuesIgnoreCase'] = variableValuesIgnoreCase;
            }

            if (parentTaskId !== undefined) {
                localVarQueryParameter['parentTaskId'] = parentTaskId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError(id: string, body?: TaskBpmnErrorDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleBpmnError.');
            }
            const localVarPath = `/task/{id}/bpmnError`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskBpmnErrorDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation(id: string, body?: TaskEscalationDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling handleEscalation.');
            }
            const localVarPath = `/task/{id}/bpmnEscalation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskEscalationDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options: any = {}): FetchArgs {
            const localVarPath = `/task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (firstResult !== undefined) {
                localVarQueryParameter['firstResult'] = firstResult;
            }

            if (maxResults !== undefined) {
                localVarQueryParameter['maxResults'] = maxResults;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount(body?: TaskQueryDto, options: any = {}): FetchArgs {
            const localVarPath = `/task/count`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskQueryDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve(id: string, body?: CompleteTaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling resolve.');
            }
            const localVarPath = `/task/{id}/resolve`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompleteTaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee(id: string, body?: UserIdDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setAssignee.');
            }
            const localVarPath = `/task/{id}/assignee`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserIdDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(id: string, body?: CompleteTaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling submit.');
            }
            const localVarPath = `/task/{id}/submit-form`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CompleteTaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling unclaim.');
            }
            const localVarPath = `/task/{id}/unclaim`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, body?: TaskDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            const localVarPath = `/task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"TaskDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(id: string, body?: UserIdDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).claim(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(id: string, body?: CompleteTaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).complete(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(body?: TaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).createTask(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask(id: string, body?: UserIdDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).delegateTask(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).deleteTask(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getDeployedForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<FormDto> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getFormVariables(id, variableNames, deserializeValues, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getRenderedForm(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TaskDto> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getTask(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TaskDto>> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).handleBpmnError(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation(id: string, body?: TaskEscalationDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).handleEscalation(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<TaskDto>> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).queryTasks(body, firstResult, maxResults, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount(body?: TaskQueryDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CountResultDto> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).queryTasksCount(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve(id: string, body?: CompleteTaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).resolve(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee(id: string, body?: UserIdDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).setAssignee(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(id: string, body?: CompleteTaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).submit(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).unclaim(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, body?: TaskDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).updateTask(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
         * @param {string} id The id of the task to claim.
         * @param {UserIdDto} [body] Provide the id of the user that claims the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claim(id: string, body?: UserIdDto, options?: any) {
            return TaskApiFp(configuration).claim(id, body, options)(fetch, basePath);
        },
        /**
         * Completes a task and updates process variables.
         * @param {string} id The id of the task to complete.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        complete(id: string, body?: CompleteTaskDto, options?: any) {
            return TaskApiFp(configuration).complete(id, body, options)(fetch, basePath);
        },
        /**
         * Creates a new task.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTask(body?: TaskDto, options?: any) {
            return TaskApiFp(configuration).createTask(body, options)(fetch, basePath);
        },
        /**
         * Delegates a task to another user.
         * @param {string} id The id of the task to delegate.
         * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delegateTask(id: string, body?: UserIdDto, options?: any) {
            return TaskApiFp(configuration).delegateTask(id, body, options)(fetch, basePath);
        },
        /**
         * Removes a task by id.
         * @param {string} id The id of the task to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: string, options?: any) {
            return TaskApiFp(configuration).deleteTask(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
         * @param {string} id The id of the task to get the deployed form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeployedForm(id: string, options?: any) {
            return TaskApiFp(configuration).getDeployedForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
         * @param {string} id The id of the task to retrieve the form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id: string, options?: any) {
            return TaskApiFp(configuration).getForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
         * @param {string} id The id of the task to retrieve the variables for.
         * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
            return TaskApiFp(configuration).getFormVariables(id, variableNames, deserializeValues, options)(fetch, basePath);
        },
        /**
         * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
         * @param {string} id The id of the task to get the rendered form for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRenderedForm(id: string, options?: any) {
            return TaskApiFp(configuration).getRenderedForm(id, options)(fetch, basePath);
        },
        /**
         * Retrieves a task by id.
         * @param {string} id The id of the task to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTask(id: string, options?: any) {
            return TaskApiFp(configuration).getTask(id, options)(fetch, basePath);
        },
        /**
         * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
         * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
            return TaskApiFp(configuration).getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
         * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
         * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
         * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
         * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
         * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
         * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
         * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
         * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
         * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
         * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
         * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
         * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
         * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
         * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
         * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
         * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
         * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
         * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
         * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
         * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
         * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
         * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
         * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
         * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
         * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
         * @param {string} [owner] Restrict to tasks that the given user owns.
         * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
         * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
         * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
         * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
         * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
         * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
         * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
         * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
         * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
         * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
         * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
         * @param {string} [name] Restrict to tasks that have the given name.
         * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
         * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
         * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
         * @param {string} [description] Restrict to tasks that have the given description.
         * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
         * @param {number} [priority] Restrict to tasks that have the given priority.
         * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
         * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
         * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
         * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
         * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
         * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
         * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
         * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
         * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
         * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
         * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
         * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
         * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
         * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
         * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
         * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
         * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
         * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
         * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
         * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: any) {
            return TaskApiFp(configuration).getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options)(fetch, basePath);
        },
        /**
         * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
         * @param {string} id The id of the task a BPMN error is reported for.
         * @param {TaskBpmnErrorDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: any) {
            return TaskApiFp(configuration).handleBpmnError(id, body, options)(fetch, basePath);
        },
        /**
         * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
         * @param {string} id The id of the task in which context a BPMN escalation is reported.
         * @param {TaskEscalationDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        handleEscalation(id: string, body?: TaskEscalationDto, options?: any) {
            return TaskApiFp(configuration).handleEscalation(id, body, options)(fetch, basePath);
        },
        /**
         * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
         * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: any) {
            return TaskApiFp(configuration).queryTasks(body, firstResult, maxResults, options)(fetch, basePath);
        },
        /**
         * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
         * @param {TaskQueryDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        queryTasksCount(body?: TaskQueryDto, options?: any) {
            return TaskApiFp(configuration).queryTasksCount(body, options)(fetch, basePath);
        },
        /**
         * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
         * @param {string} id The id of the task to resolve.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resolve(id: string, body?: CompleteTaskDto, options?: any) {
            return TaskApiFp(configuration).resolve(id, body, options)(fetch, basePath);
        },
        /**
         * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
         * @param {string} id The id of the task to set the assignee for.
         * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAssignee(id: string, body?: UserIdDto, options?: any) {
            return TaskApiFp(configuration).setAssignee(id, body, options)(fetch, basePath);
        },
        /**
         * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
         * @param {string} id The id of the task to submit the form for.
         * @param {CompleteTaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submit(id: string, body?: CompleteTaskDto, options?: any) {
            return TaskApiFp(configuration).submit(id, body, options)(fetch, basePath);
        },
        /**
         * Resets a task's assignee. If successful, the task is not assigned to a user.
         * @param {string} id The id of the task to unclaim.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unclaim(id: string, options?: any) {
            return TaskApiFp(configuration).unclaim(id, options)(fetch, basePath);
        },
        /**
         * Updates a task.
         * @param {string} id The id of the task to be updated.
         * @param {TaskDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: string, body?: TaskDto, options?: any) {
            return TaskApiFp(configuration).updateTask(id, body, options)(fetch, basePath);
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Claims a task for a specific user.  **Note:** The difference with the [Set Assignee](https://docs.camunda.org/manual/7.13/reference/rest/task/post-assignee/) method is that here a check is performed to see if the task already has a user assigned to it.
     * @param {string} id The id of the task to claim.
     * @param {UserIdDto} [body] Provide the id of the user that claims the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public claim(id: string, body?: UserIdDto, options?: any) {
        return TaskApiFp(this.configuration).claim(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Completes a task and updates process variables.
     * @param {string} id The id of the task to complete.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public complete(id: string, body?: CompleteTaskDto, options?: any) {
        return TaskApiFp(this.configuration).complete(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Creates a new task.
     * @param {TaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public createTask(body?: TaskDto, options?: any) {
        return TaskApiFp(this.configuration).createTask(body, options)(this.fetch, this.basePath);
    }

    /**
     * Delegates a task to another user.
     * @param {string} id The id of the task to delegate.
     * @param {UserIdDto} [body] Provide the id of the user that the task should be delegated to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public delegateTask(id: string, body?: UserIdDto, options?: any) {
        return TaskApiFp(this.configuration).delegateTask(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Removes a task by id.
     * @param {string} id The id of the task to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(id: string, options?: any) {
        return TaskApiFp(this.configuration).deleteTask(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the deployed form that is referenced from a given task. For further information please refer to the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#embedded-task-forms).
     * @param {string} id The id of the task to get the deployed form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getDeployedForm(id: string, options?: any) {
        return TaskApiFp(this.configuration).getDeployedForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the form key for a task. The form key corresponds to the `FormData#formKey` property in the engine. This key can be used to do task-specific form rendering in client applications. Additionally, the context path of the containing process application is returned.
     * @param {string} id The id of the task to retrieve the form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getForm(id: string, options?: any) {
        return TaskApiFp(this.configuration).getForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the form variables for a task. The form variables take form data specified on the task into account. If form fields are defined, the variable types and default values of the form fields are taken into account.
     * @param {string} id The id of the task to retrieve the variables for.
     * @param {string} [variableNames] A comma-separated list of variable names. Allows restricting the list of requested variables to the variable names in the list. It is best practice to restrict the list of variables to the variables actually required by the form in order to minimize fetching of data. If the query parameter is ommitted all variables are fetched. If the query parameter contains non-existent variable names, the variable names are ignored.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on server side (default true).  If set to true, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](http://jackson.codehaus.org/) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to false, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While true is the default value for reasons of backward compatibility, we recommend setting this parameter to false when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getFormVariables(id: string, variableNames?: string, deserializeValues?: boolean, options?: any) {
        return TaskApiFp(this.configuration).getFormVariables(id, variableNames, deserializeValues, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the rendered form for a task. This method can be used to get the HTML rendering of a [Generated Task Form](https://docs.camunda.org/manual/7.13/user-guide/task-forms/#generated-task-forms).
     * @param {string} id The id of the task to get the rendered form for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getRenderedForm(id: string, options?: any) {
        return TaskApiFp(this.configuration).getRenderedForm(id, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a task by id.
     * @param {string} id The id of the task to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTask(id: string, options?: any) {
        return TaskApiFp(this.configuration).getTask(id, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for tasks that fulfill a given filter. The size of the result set can be retrieved by using the Get Task Count method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {string} [sortBy] Sort the results lexicographically by a given criterion. Must be used in conjunction with the sortOrder parameter.
     * @param {string} [sortOrder] Sort the results in a given order. Values may be asc for ascending order or desc for descending order. Must be used in conjunction with the sortBy parameter.
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasks(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, sortBy?: string, sortOrder?: string, firstResult?: number, maxResults?: number, options?: any) {
        return TaskApiFp(this.configuration).getTasks(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, sortBy, sortOrder, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the number of tasks that fulfill a provided filter. Corresponds to the size of the result set when using the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/) method.  **Security Consideration:** There are several query parameters (such as assigneeExpression) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) for custom code in the user guide for details.
     * @param {string} [processInstanceId] Restrict to tasks that belong to process instances with the given id.
     * @param {string} [processInstanceIdIn] Restrict to tasks that belong to process instances with the given ids.
     * @param {string} [processInstanceBusinessKey] Restrict to tasks that belong to process instances with the given business key.
     * @param {string} [processInstanceBusinessKeyExpression] Restrict to tasks that belong to process instances with the given business key which  is described by an expression. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {string} [processInstanceBusinessKeyIn] Restrict to tasks that belong to process instances with one of the give business keys.  The keys need to be in a comma-separated list.
     * @param {string} [processInstanceBusinessKeyLike] Restrict to tasks that have a process instance business key that has the parameter  value as a substring.
     * @param {string} [processInstanceBusinessKeyLikeExpression] Restrict to tasks that have a process instance business key that has the parameter  value as a substring and is described by an expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [processDefinitionId] Restrict to tasks that belong to a process definition with the given id.
     * @param {string} [processDefinitionKey] Restrict to tasks that belong to a process definition with the given key.
     * @param {string} [processDefinitionKeyIn] Restrict to tasks that belong to a process definition with one of the given keys. The  keys need to be in a comma-separated list.
     * @param {string} [processDefinitionName] Restrict to tasks that belong to a process definition with the given name.
     * @param {string} [processDefinitionNameLike] Restrict to tasks that have a process definition name that has the parameter value as  a substring.
     * @param {string} [executionId] Restrict to tasks that belong to an execution with the given id.
     * @param {string} [caseInstanceId] Restrict to tasks that belong to case instances with the given id.
     * @param {string} [caseInstanceBusinessKey] Restrict to tasks that belong to case instances with the given business key.
     * @param {string} [caseInstanceBusinessKeyLike] Restrict to tasks that have a case instance business key that has the parameter value  as a substring.
     * @param {string} [caseDefinitionId] Restrict to tasks that belong to a case definition with the given id.
     * @param {string} [caseDefinitionKey] Restrict to tasks that belong to a case definition with the given key.
     * @param {string} [caseDefinitionName] Restrict to tasks that belong to a case definition with the given name.
     * @param {string} [caseDefinitionNameLike] Restrict to tasks that have a case definition name that has the parameter value as a  substring.
     * @param {string} [caseExecutionId] Restrict to tasks that belong to a case execution with the given id.
     * @param {string} [activityInstanceIdIn] Only include tasks which belong to one of the passed and comma-separated activity  instance ids.
     * @param {string} [tenantIdIn] Only include tasks which belong to one of the passed and comma-separated  tenant ids.
     * @param {boolean} [withoutTenantId] Only include tasks which belong to no tenant. Value may only be &#x60;true&#x60;,  as &#x60;false&#x60; is the default behavior.
     * @param {string} [assignee] Restrict to tasks that the given user is assigned to.
     * @param {string} [assigneeExpression] Restrict to tasks that the user described by the given expression is assigned to.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeLike] Restrict to tasks that have an assignee that has the parameter  value as a substring.
     * @param {string} [assigneeLikeExpression] Restrict to tasks that have an assignee that has the parameter value described by the  given expression as a substring. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [assigneeIn] Only include tasks which are assigned to one of the passed and  comma-separated user ids.
     * @param {string} [owner] Restrict to tasks that the given user owns.
     * @param {string} [ownerExpression] Restrict to tasks that the user described by the given expression owns. See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateGroup] Only include tasks that are offered to the given group.
     * @param {string} [candidateGroupExpression] Only include tasks that are offered to the group described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {string} [candidateUser] Only include tasks that are offered to the given user or to one of his groups.
     * @param {string} [candidateUserExpression] Only include tasks that are offered to the user described by the given expression.  See the  [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions)  for more information on available functions.
     * @param {boolean} [includeAssignedTasks] Also include tasks that are assigned to users in candidate queries. Default is to only  include tasks that are not assigned to any user if you query by candidate user or group(s).
     * @param {string} [involvedUser] Only include tasks that the given user is involved in. A user is involved in a task if  an identity link exists between task and user (e.g., the user is the assignee).
     * @param {string} [involvedUserExpression] Only include tasks that the user described by the given expression is involved in. A user is involved in a task if an identity link exists between task and user (e.g., the user is the assignee). See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions.
     * @param {boolean} [assigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are assigned.
     * @param {boolean} [unassigned] If set to &#x60;true&#x60;, restricts the query to all tasks that are unassigned.
     * @param {string} [taskDefinitionKey] Restrict to tasks that have the given key.
     * @param {string} [taskDefinitionKeyIn] Restrict to tasks that have one of the given keys. The keys need to be in a comma-separated list.
     * @param {string} [taskDefinitionKeyLike] Restrict to tasks that have a key that has the parameter value as a substring.
     * @param {string} [name] Restrict to tasks that have the given name.
     * @param {string} [nameNotEqual] Restrict to tasks that do not have the given name.
     * @param {string} [nameLike] Restrict to tasks that have a name with the given parameter value as substring.
     * @param {string} [nameNotLike] Restrict to tasks that do not have a name with the given parameter value as substring.
     * @param {string} [description] Restrict to tasks that have the given description.
     * @param {string} [descriptionLike] Restrict to tasks that have a description that has the parameter value as a substring.
     * @param {number} [priority] Restrict to tasks that have the given priority.
     * @param {number} [maxPriority] Restrict to tasks that have a lower or equal priority.
     * @param {number} [minPriority] Restrict to tasks that have a higher or equal priority.
     * @param {string} [dueDate] Restrict to tasks that are due on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.546+0200&#x60;.
     * @param {string} [dueDateExpression] Restrict to tasks that are due on the date described by the given expression. See the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueAfter] Restrict to tasks that are due after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.435+0200&#x60;.
     * @param {string} [dueAfterExpression] Restrict to tasks that are due after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [dueBefore] Restrict to tasks that are due before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.243+0200&#x60;.
     * @param {string} [dueBeforeExpression] Restrict to tasks that are due before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpDate] Restrict to tasks that have a followUp date on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [followUpDateExpression] Restrict to tasks that have a followUp date on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpAfter] Restrict to tasks that have a followUp date after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.542+0200&#x60;.
     * @param {string} [followUpAfterExpression] Restrict to tasks that have a followUp date after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBefore] Restrict to tasks that have a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.234+0200&#x60;.
     * @param {string} [followUpBeforeExpression] Restrict to tasks that have a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [followUpBeforeOrNotExistent] Restrict to tasks that have no followUp date or a followUp date before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.432+0200&#x60;. The typical use case is to query all &#x60;active&#x60; tasks for a user for a given date.
     * @param {string} [followUpBeforeOrNotExistentExpression] Restrict to tasks that have no followUp date or a followUp date before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdOn] Restrict to tasks that were created on the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.324+0200&#x60;.
     * @param {string} [createdOnExpression] Restrict to tasks that were created on the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdAfter] Restrict to tasks that were created after the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.342+0200&#x60;.
     * @param {string} [createdAfterExpression] Restrict to tasks that were created after the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [createdBefore] Restrict to tasks that were created before the given date. By [default](https://docs.camunda.org/manual/7.13/reference/rest/overview/date-format/), the date must have the format &#x60;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSZ&#x60;, e.g., &#x60;2013-01-23T14:42:45.332+0200&#x60;.
     * @param {string} [createdBeforeExpression] Restrict to tasks that were created before the date described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to a &#x60;java.util.Date&#x60; or &#x60;org.joda.time.DateTime&#x60; object.
     * @param {string} [delegationState] Restrict to tasks that are in the given delegation state. Valid values are &#x60;PENDING&#x60; and &#x60;RESOLVED&#x60;.
     * @param {string} [candidateGroups] Restrict to tasks that are offered to any of the given candidate groups. Takes a comma-separated list of group names, so for example &#x60;developers,support,sales&#x60;.
     * @param {string} [candidateGroupsExpression] Restrict to tasks that are offered to any of the candidate groups described by the given expression. See the [user guide](https://docs.camunda.org/manual/7.13/user-guide/process-engine/expression-language/#internal-context-functions) for more information on available functions. The expression must evaluate to &#x60;java.util.List&#x60; of Strings.
     * @param {boolean} [withCandidateGroups] Only include tasks which have a candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateGroups] Only include tasks which have no candidate group. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withCandidateUsers] Only include tasks which have a candidate user. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [withoutCandidateUsers] Only include tasks which have no candidate users. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [active] Only include active tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {boolean} [suspended] Only include suspended tasks. Value may only be &#x60;true&#x60;, as &#x60;false&#x60; is the default behavior.
     * @param {string} [taskVariables] Only include tasks that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [processVariables] Only include tasks that belong to process instances that have variables with certain  values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {string} [caseInstanceVariables] Only include tasks that belong to case instances that have variables with certain values. Variable filtering expressions are comma-separated and are structured as follows:  A valid parameter value has the form &#x60;key_operator_value&#x60;. &#x60;key&#x60; is the variable name, &#x60;operator&#x60; is the comparison operator to be used and &#x60;value&#x60; the variable value.  **Note**: Values are always treated as String objects on server side.  Valid &#x60;operator&#x60; values are: &#x60;eq&#x60; - equal to; &#x60;neq&#x60; - not equal to; &#x60;gt&#x60; - greater than; &#x60;gteq&#x60; - greater than or equal to; &#x60;lt&#x60; - lower than; &#x60;lteq&#x60; - lower than or equal to; &#x60;like&#x60;. &#x60;key&#x60; and &#x60;value&#x60; may not contain underscore or comma characters.
     * @param {boolean} [variableNamesIgnoreCase] Match all variable names in this query case-insensitively. If set &#x60;variableName&#x60; and &#x60;variablename&#x60; are treated as equal.
     * @param {boolean} [variableValuesIgnoreCase] Match all variable values in this query case-insensitively. If set &#x60;variableValue&#x60; and &#x60;variablevalue&#x60; are treated as equal.
     * @param {string} [parentTaskId] Restrict query to all tasks that are sub tasks of the given task. Takes a task id.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasksCount(processInstanceId?: string, processInstanceIdIn?: string, processInstanceBusinessKey?: string, processInstanceBusinessKeyExpression?: string, processInstanceBusinessKeyIn?: string, processInstanceBusinessKeyLike?: string, processInstanceBusinessKeyLikeExpression?: string, processDefinitionId?: string, processDefinitionKey?: string, processDefinitionKeyIn?: string, processDefinitionName?: string, processDefinitionNameLike?: string, executionId?: string, caseInstanceId?: string, caseInstanceBusinessKey?: string, caseInstanceBusinessKeyLike?: string, caseDefinitionId?: string, caseDefinitionKey?: string, caseDefinitionName?: string, caseDefinitionNameLike?: string, caseExecutionId?: string, activityInstanceIdIn?: string, tenantIdIn?: string, withoutTenantId?: boolean, assignee?: string, assigneeExpression?: string, assigneeLike?: string, assigneeLikeExpression?: string, assigneeIn?: string, owner?: string, ownerExpression?: string, candidateGroup?: string, candidateGroupExpression?: string, candidateUser?: string, candidateUserExpression?: string, includeAssignedTasks?: boolean, involvedUser?: string, involvedUserExpression?: string, assigned?: boolean, unassigned?: boolean, taskDefinitionKey?: string, taskDefinitionKeyIn?: string, taskDefinitionKeyLike?: string, name?: string, nameNotEqual?: string, nameLike?: string, nameNotLike?: string, description?: string, descriptionLike?: string, priority?: number, maxPriority?: number, minPriority?: number, dueDate?: string, dueDateExpression?: string, dueAfter?: string, dueAfterExpression?: string, dueBefore?: string, dueBeforeExpression?: string, followUpDate?: string, followUpDateExpression?: string, followUpAfter?: string, followUpAfterExpression?: string, followUpBefore?: string, followUpBeforeExpression?: string, followUpBeforeOrNotExistent?: string, followUpBeforeOrNotExistentExpression?: string, createdOn?: string, createdOnExpression?: string, createdAfter?: string, createdAfterExpression?: string, createdBefore?: string, createdBeforeExpression?: string, delegationState?: string, candidateGroups?: string, candidateGroupsExpression?: string, withCandidateGroups?: boolean, withoutCandidateGroups?: boolean, withCandidateUsers?: boolean, withoutCandidateUsers?: boolean, active?: boolean, suspended?: boolean, taskVariables?: string, processVariables?: string, caseInstanceVariables?: string, variableNamesIgnoreCase?: boolean, variableValuesIgnoreCase?: boolean, parentTaskId?: string, options?: any) {
        return TaskApiFp(this.configuration).getTasksCount(processInstanceId, processInstanceIdIn, processInstanceBusinessKey, processInstanceBusinessKeyExpression, processInstanceBusinessKeyIn, processInstanceBusinessKeyLike, processInstanceBusinessKeyLikeExpression, processDefinitionId, processDefinitionKey, processDefinitionKeyIn, processDefinitionName, processDefinitionNameLike, executionId, caseInstanceId, caseInstanceBusinessKey, caseInstanceBusinessKeyLike, caseDefinitionId, caseDefinitionKey, caseDefinitionName, caseDefinitionNameLike, caseExecutionId, activityInstanceIdIn, tenantIdIn, withoutTenantId, assignee, assigneeExpression, assigneeLike, assigneeLikeExpression, assigneeIn, owner, ownerExpression, candidateGroup, candidateGroupExpression, candidateUser, candidateUserExpression, includeAssignedTasks, involvedUser, involvedUserExpression, assigned, unassigned, taskDefinitionKey, taskDefinitionKeyIn, taskDefinitionKeyLike, name, nameNotEqual, nameLike, nameNotLike, description, descriptionLike, priority, maxPriority, minPriority, dueDate, dueDateExpression, dueAfter, dueAfterExpression, dueBefore, dueBeforeExpression, followUpDate, followUpDateExpression, followUpAfter, followUpAfterExpression, followUpBefore, followUpBeforeExpression, followUpBeforeOrNotExistent, followUpBeforeOrNotExistentExpression, createdOn, createdOnExpression, createdAfter, createdAfterExpression, createdBefore, createdBeforeExpression, delegationState, candidateGroups, candidateGroupsExpression, withCandidateGroups, withoutCandidateGroups, withCandidateUsers, withoutCandidateUsers, active, suspended, taskVariables, processVariables, caseInstanceVariables, variableNamesIgnoreCase, variableValuesIgnoreCase, parentTaskId, options)(this.fetch, this.basePath);
    }

    /**
     * Reports a business error in the context of a running task by id. The error code must be specified to identify the BPMN error handler. See the documentation for [Reporting Bpmn Error](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-error) in User Tasks.
     * @param {string} id The id of the task a BPMN error is reported for.
     * @param {TaskBpmnErrorDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public handleBpmnError(id: string, body?: TaskBpmnErrorDto, options?: any) {
        return TaskApiFp(this.configuration).handleBpmnError(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Reports an escalation in the context of a running task by id. The escalation code must be specified to identify the escalation handler. See the documentation for [Reporting Bpmn Escalation](https://docs.camunda.org/manual/7.13/reference/bpmn20/tasks/user-task/#reporting-bpmn-escalation) in User Tasks.
     * @param {string} id The id of the task in which context a BPMN escalation is reported.
     * @param {TaskEscalationDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public handleEscalation(id: string, body?: TaskEscalationDto, options?: any) {
        return TaskApiFp(this.configuration).handleEscalation(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Queries for tasks that fulfill a given filter. This method is slightly more powerful than the [Get Tasks](https://docs.camunda.org/manual/7.13/reference/rest/task/get-query/) method because it allows filtering by multiple process or task variables of types `String`, `Number` or `Boolean`. The size of the result set can be retrieved by using the [Get Task Count (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query-count/) method.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {TaskQueryDto} [body] 
     * @param {number} [firstResult] Pagination of results. Specifies the index of the first result to return.
     * @param {number} [maxResults] Pagination of results. Specifies the maximum number of results to return. Will return less results if there are no more results left.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public queryTasks(body?: TaskQueryDto, firstResult?: number, maxResults?: number, options?: any) {
        return TaskApiFp(this.configuration).queryTasks(body, firstResult, maxResults, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the number of tasks that fulfill the given filter. Corresponds to the size of the result set of the [Get Tasks (POST)](https://docs.camunda.org/manual/7.13/reference/rest/task/post-query/) method and takes the same parameters.  **Security Consideration**: There are several parameters (such as `assigneeExpression`) for specifying an EL expression. These are disabled by default to prevent remote code execution. See the section on [security considerations for custom code](https://docs.camunda.org/manual/7.13/user-guide/process-engine/securing-custom-code/) in the user guide for details.
     * @param {TaskQueryDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public queryTasksCount(body?: TaskQueryDto, options?: any) {
        return TaskApiFp(this.configuration).queryTasksCount(body, options)(this.fetch, this.basePath);
    }

    /**
     * Resolves a task and updates execution variables.  Resolving a task marks that the assignee is done with the task delegated to them, and that it can be sent back to the owner. Can only be executed when the task has been delegated. The assignee will be set to the owner, who performed the delegation.
     * @param {string} id The id of the task to resolve.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public resolve(id: string, body?: CompleteTaskDto, options?: any) {
        return TaskApiFp(this.configuration).resolve(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Changes the assignee of a task to a specific user.  **Note:** The difference with the [Claim Task](https://docs.camunda.org/manual/7.13/reference/rest/task/post-claim/) method is that this method does not check if the task already has a user assigned to it.
     * @param {string} id The id of the task to set the assignee for.
     * @param {UserIdDto} [body] Provide the id of the user that will be the assignee of the task.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public setAssignee(id: string, body?: UserIdDto, options?: any) {
        return TaskApiFp(this.configuration).setAssignee(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Completes a task and updates process variables using a form submit. There are two difference between this method and the `complete` method:  * If the task is in state `PENDING` - i.e., has been delegated before, it is not completed but resolved. Otherwise it will be completed. * If the task has Form Field Metadata defined, the process engine will perform backend validation for any form fields which have validators defined. See the [Generated Task Forms](https://docs.camunda.org/manual/7.13/user-guide/task-forms/_index/#generated-task-forms) section of the [User Guide](https://docs.camunda.org/manual/7.13/user-guide/) for more information.
     * @param {string} id The id of the task to submit the form for.
     * @param {CompleteTaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public submit(id: string, body?: CompleteTaskDto, options?: any) {
        return TaskApiFp(this.configuration).submit(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Resets a task's assignee. If successful, the task is not assigned to a user.
     * @param {string} id The id of the task to unclaim.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public unclaim(id: string, options?: any) {
        return TaskApiFp(this.configuration).unclaim(id, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a task.
     * @param {string} id The id of the task to be updated.
     * @param {TaskDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: string, body?: TaskDto, options?: any) {
        return TaskApiFp(this.configuration).updateTask(id, body, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskAttachmentApi - fetch parameter creator
 * @export
 */
export const TaskAttachmentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] 
         * @param {string} [attachmentDescription] 
         * @param {string} [attachmentType] 
         * @param {string} [url] 
         * @param {Blob} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addAttachment.');
            }
            const localVarPath = `/task/{id}/attachment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (attachmentName !== undefined) {
                localVarFormParams.set('attachment-name', attachmentName as any);
            }

            if (attachmentDescription !== undefined) {
                localVarFormParams.set('attachment-description', attachmentDescription as any);
            }

            if (attachmentType !== undefined) {
                localVarFormParams.set('attachment-type', attachmentType as any);
            }

            if (url !== undefined) {
                localVarFormParams.set('url', url as any);
            }

            if (content !== undefined) {
                localVarFormParams.set('content', content as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, attachmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling deleteAttachment.');
            }
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, attachmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAttachment.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling getAttachment.');
            }
            const localVarPath = `/task/{id}/attachment/{attachmentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData(id: string, attachmentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAttachmentData.');
            }
            // verify required parameter 'attachmentId' is not null or undefined
            if (attachmentId === null || attachmentId === undefined) {
                throw new RequiredError('attachmentId','Required parameter attachmentId was null or undefined when calling getAttachmentData.');
            }
            const localVarPath = `/task/{id}/attachment/{attachmentId}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"attachmentId"}}`, encodeURIComponent(String(attachmentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getAttachments.');
            }
            const localVarPath = `/task/{id}/attachment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskAttachmentApi - functional programming interface
 * @export
 */
export const TaskAttachmentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] 
         * @param {string} [attachmentDescription] 
         * @param {string} [attachmentType] 
         * @param {string} [url] 
         * @param {Blob} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentDto> {
            const localVarFetchArgs = TaskAttachmentApiFetchParamCreator(configuration).addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, attachmentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskAttachmentApiFetchParamCreator(configuration).deleteAttachment(id, attachmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, attachmentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<AttachmentDto> {
            const localVarFetchArgs = TaskAttachmentApiFetchParamCreator(configuration).getAttachment(id, attachmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData(id: string, attachmentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TaskAttachmentApiFetchParamCreator(configuration).getAttachmentData(id, attachmentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<AttachmentDto>> {
            const localVarFetchArgs = TaskAttachmentApiFetchParamCreator(configuration).getAttachments(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskAttachmentApi - factory interface
 * @export
 */
export const TaskAttachmentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates an attachment for a task.
         * @param {string} id The id of the task to add the attachment to.
         * @param {string} [attachmentName] 
         * @param {string} [attachmentDescription] 
         * @param {string} [attachmentType] 
         * @param {string} [url] 
         * @param {Blob} [content] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: Blob, options?: any) {
            return TaskAttachmentApiFp(configuration).addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options)(fetch, basePath);
        },
        /**
         * Removes an attachment from a task by id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAttachment(id: string, attachmentId: string, options?: any) {
            return TaskAttachmentApiFp(configuration).deleteAttachment(id, attachmentId, options)(fetch, basePath);
        },
        /**
         * Retrieves a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachment(id: string, attachmentId: string, options?: any) {
            return TaskAttachmentApiFp(configuration).getAttachment(id, attachmentId, options)(fetch, basePath);
        },
        /**
         * Retrieves the binary content of a task attachment by task id and attachment id.
         * @param {string} id The id of the task.
         * @param {string} attachmentId The id of the attachment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachmentData(id: string, attachmentId: string, options?: any) {
            return TaskAttachmentApiFp(configuration).getAttachmentData(id, attachmentId, options)(fetch, basePath);
        },
        /**
         * Gets the attachments for a task.
         * @param {string} id The id of the task to retrieve the attachments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAttachments(id: string, options?: any) {
            return TaskAttachmentApiFp(configuration).getAttachments(id, options)(fetch, basePath);
        },
    };
};

/**
 * TaskAttachmentApi - object-oriented interface
 * @export
 * @class TaskAttachmentApi
 * @extends {BaseAPI}
 */
export class TaskAttachmentApi extends BaseAPI {
    /**
     * Creates an attachment for a task.
     * @param {string} id The id of the task to add the attachment to.
     * @param {string} [attachmentName] 
     * @param {string} [attachmentDescription] 
     * @param {string} [attachmentType] 
     * @param {string} [url] 
     * @param {Blob} [content] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public addAttachment(id: string, attachmentName?: string, attachmentDescription?: string, attachmentType?: string, url?: string, content?: Blob, options?: any) {
        return TaskAttachmentApiFp(this.configuration).addAttachment(id, attachmentName, attachmentDescription, attachmentType, url, content, options)(this.fetch, this.basePath);
    }

    /**
     * Removes an attachment from a task by id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public deleteAttachment(id: string, attachmentId: string, options?: any) {
        return TaskAttachmentApiFp(this.configuration).deleteAttachment(id, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachment(id: string, attachmentId: string, options?: any) {
        return TaskAttachmentApiFp(this.configuration).getAttachment(id, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves the binary content of a task attachment by task id and attachment id.
     * @param {string} id The id of the task.
     * @param {string} attachmentId The id of the attachment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachmentData(id: string, attachmentId: string, options?: any) {
        return TaskAttachmentApiFp(this.configuration).getAttachmentData(id, attachmentId, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the attachments for a task.
     * @param {string} id The id of the task to retrieve the attachments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskAttachmentApi
     */
    public getAttachments(id: string, options?: any) {
        return TaskAttachmentApiFp(this.configuration).getAttachments(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskCommentApi - fetch parameter creator
 * @export
 */
export const TaskCommentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [body] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id: string, body?: CommentDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling createComment.');
            }
            const localVarPath = `/task/{id}/comment/create`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"CommentDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: string, commentId: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getComment.');
            }
            // verify required parameter 'commentId' is not null or undefined
            if (commentId === null || commentId === undefined) {
                throw new RequiredError('commentId','Required parameter commentId was null or undefined when calling getComment.');
            }
            const localVarPath = `/task/{id}/comment/{commentId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"commentId"}}`, encodeURIComponent(String(commentId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getComments.');
            }
            const localVarPath = `/task/{id}/comment`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskCommentApi - functional programming interface
 * @export
 */
export const TaskCommentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [body] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id: string, body?: CommentDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = TaskCommentApiFetchParamCreator(configuration).createComment(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: string, commentId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<CommentDto> {
            const localVarFetchArgs = TaskCommentApiFetchParamCreator(configuration).getComment(id, commentId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<CommentDto>> {
            const localVarFetchArgs = TaskCommentApiFetchParamCreator(configuration).getComments(id, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskCommentApi - factory interface
 * @export
 */
export const TaskCommentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Creates a comment for a task by id.
         * @param {string} id The id of the task to add the comment to.
         * @param {CommentDto} [body] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComment(id: string, body?: CommentDto, options?: any) {
            return TaskCommentApiFp(configuration).createComment(id, body, options)(fetch, basePath);
        },
        /**
         * Retrieves a task comment by task id and comment id.
         * @param {string} id The id of the task.
         * @param {string} commentId The id of the comment to be retrieved.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComment(id: string, commentId: string, options?: any) {
            return TaskCommentApiFp(configuration).getComment(id, commentId, options)(fetch, basePath);
        },
        /**
         * Gets the comments for a task by id.
         * @param {string} id The id of the task to retrieve the comments for.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getComments(id: string, options?: any) {
            return TaskCommentApiFp(configuration).getComments(id, options)(fetch, basePath);
        },
    };
};

/**
 * TaskCommentApi - object-oriented interface
 * @export
 * @class TaskCommentApi
 * @extends {BaseAPI}
 */
export class TaskCommentApi extends BaseAPI {
    /**
     * Creates a comment for a task by id.
     * @param {string} id The id of the task to add the comment to.
     * @param {CommentDto} [body] **Note:** Only the &#x60;message&#x60; property will be used. Every other property passed to this endpoint will be ignored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public createComment(id: string, body?: CommentDto, options?: any) {
        return TaskCommentApiFp(this.configuration).createComment(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a task comment by task id and comment id.
     * @param {string} id The id of the task.
     * @param {string} commentId The id of the comment to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public getComment(id: string, commentId: string, options?: any) {
        return TaskCommentApiFp(this.configuration).getComment(id, commentId, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the comments for a task by id.
     * @param {string} id The id of the task to retrieve the comments for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskCommentApi
     */
    public getComments(id: string, options?: any) {
        return TaskCommentApiFp(this.configuration).getComments(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskIdentityLinkApi - fetch parameter creator
 * @export
 */
export const TaskIdentityLinkApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink(id: string, body?: IdentityLinkDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addIdentityLink.');
            }
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdentityLinkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink(id: string, body?: IdentityLinkDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteIdentityLink.');
            }
            const localVarPath = `/task/{id}/identity-links/delete`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"IdentityLinkDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks(id: string, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getIdentityLinks.');
            }
            const localVarPath = `/task/{id}/identity-links`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskIdentityLinkApi - functional programming interface
 * @export
 */
export const TaskIdentityLinkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink(id: string, body?: IdentityLinkDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskIdentityLinkApiFetchParamCreator(configuration).addIdentityLink(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink(id: string, body?: IdentityLinkDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskIdentityLinkApiFetchParamCreator(configuration).deleteIdentityLink(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks(id: string, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<IdentityLinkDto>> {
            const localVarFetchArgs = TaskIdentityLinkApiFetchParamCreator(configuration).getIdentityLinks(id, type, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskIdentityLinkApi - factory interface
 * @export
 */
export const TaskIdentityLinkApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
         * @param {string} id The id of the task to add a link to.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addIdentityLink(id: string, body?: IdentityLinkDto, options?: any) {
            return TaskIdentityLinkApiFp(configuration).addIdentityLink(id, body, options)(fetch, basePath);
        },
        /**
         * Removes an identity link from a task by id
         * @param {string} id The id of the task to remove a link from.
         * @param {IdentityLinkDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteIdentityLink(id: string, body?: IdentityLinkDto, options?: any) {
            return TaskIdentityLinkApiFp(configuration).deleteIdentityLink(id, body, options)(fetch, basePath);
        },
        /**
         * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
         * @param {string} id The id of the task to retrieve the identity links for.
         * @param {string} [type] Filter by the type of links to include.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIdentityLinks(id: string, type?: string, options?: any) {
            return TaskIdentityLinkApiFp(configuration).getIdentityLinks(id, type, options)(fetch, basePath);
        },
    };
};

/**
 * TaskIdentityLinkApi - object-oriented interface
 * @export
 * @class TaskIdentityLinkApi
 * @extends {BaseAPI}
 */
export class TaskIdentityLinkApi extends BaseAPI {
    /**
     * Adds an identity link to a task by id. Can be used to link any user or group to a task and specify a relation.
     * @param {string} id The id of the task to add a link to.
     * @param {IdentityLinkDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public addIdentityLink(id: string, body?: IdentityLinkDto, options?: any) {
        return TaskIdentityLinkApiFp(this.configuration).addIdentityLink(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Removes an identity link from a task by id
     * @param {string} id The id of the task to remove a link from.
     * @param {IdentityLinkDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public deleteIdentityLink(id: string, body?: IdentityLinkDto, options?: any) {
        return TaskIdentityLinkApiFp(this.configuration).deleteIdentityLink(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Gets the identity links for a task by id, which are the users and groups that are in *some* relation to it (including assignee and owner).
     * @param {string} id The id of the task to retrieve the identity links for.
     * @param {string} [type] Filter by the type of links to include.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskIdentityLinkApi
     */
    public getIdentityLinks(id: string, type?: string, options?: any) {
        return TaskIdentityLinkApiFp(this.configuration).getIdentityLinks(id, type, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskLocalVariableApi - fetch parameter creator
 * @export
 */
export const TaskLocalVariableApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTaskLocalVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling deleteTaskLocalVariable.');
            }
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskLocalVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getTaskLocalVariable.');
            }
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskLocalVariableBinary.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getTaskLocalVariableBinary.');
            }
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables(id: string, deserializeValues?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskLocalVariables.');
            }
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValues !== undefined) {
                localVarQueryParameter['deserializeValues'] = deserializeValues;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables(id: string, body?: PatchVariablesDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyTaskLocalVariables.');
            }
            const localVarPath = `/task/{id}/localVariables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchVariablesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable(id: string, varName: string, body?: VariableValueDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putTaskLocalVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling putTaskLocalVariable.');
            }
            const localVarPath = `/task/{id}/localVariables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VariableValueDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable(id: string, varName: string, data?: Blob, valueType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setBinaryTaskLocalVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling setBinaryTaskLocalVariable.');
            }
            const localVarPath = `/task/{id}/localVariables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (data !== undefined) {
                localVarFormParams.set('data', data as any);
            }

            if (valueType !== undefined) {
                localVarFormParams.set('valueType', valueType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskLocalVariableApi - functional programming interface
 * @export
 */
export const TaskLocalVariableApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).deleteTaskLocalVariable(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VariableValueDto> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).getTaskLocalVariable(id, varName, deserializeValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).getTaskLocalVariableBinary(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).getTaskLocalVariables(id, deserializeValues, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables(id: string, body?: PatchVariablesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).modifyTaskLocalVariables(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable(id: string, varName: string, body?: VariableValueDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).putTaskLocalVariable(id, varName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskLocalVariableApiFetchParamCreator(configuration).setBinaryTaskLocalVariable(id, varName, data, valueType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskLocalVariableApi - factory interface
 * @export
 */
export const TaskLocalVariableApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Removes a local variable from a task by id.
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskLocalVariable(id: string, varName: string, options?: any) {
            return TaskLocalVariableApiFp(configuration).deleteTaskLocalVariable(id, varName, options)(fetch, basePath);
        },
        /**
         * Retrieves a variable from the context of a given task by id.
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
            return TaskLocalVariableApiFp(configuration).getTaskLocalVariable(id, varName, deserializeValue, options)(fetch, basePath);
        },
        /**
         * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariableBinary(id: string, varName: string, options?: any) {
            return TaskLocalVariableApiFp(configuration).getTaskLocalVariableBinary(id, varName, options)(fetch, basePath);
        },
        /**
         * Retrieves all variables of a given task by id.
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: any) {
            return TaskLocalVariableApiFp(configuration).getTaskLocalVariables(id, deserializeValues, options)(fetch, basePath);
        },
        /**
         * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskLocalVariables(id: string, body?: PatchVariablesDto, options?: any) {
            return TaskLocalVariableApiFp(configuration).modifyTaskLocalVariables(id, body, options)(fetch, basePath);
        },
        /**
         * Sets a variable in the context of a given task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskLocalVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
            return TaskLocalVariableApiFp(configuration).putTaskLocalVariable(id, varName, body, options)(fetch, basePath);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable.
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskLocalVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
            return TaskLocalVariableApiFp(configuration).setBinaryTaskLocalVariable(id, varName, data, valueType, options)(fetch, basePath);
        },
    };
};

/**
 * TaskLocalVariableApi - object-oriented interface
 * @export
 * @class TaskLocalVariableApi
 * @extends {BaseAPI}
 */
export class TaskLocalVariableApi extends BaseAPI {
    /**
     * Removes a local variable from a task by id.
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public deleteTaskLocalVariable(id: string, varName: string, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).deleteTaskLocalVariable(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a variable from the context of a given task by id.
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariable(id, varName, deserializeValue, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a binary variable from the context of a given task by id. Applicable for byte array and file variables.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariableBinary(id: string, varName: string, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariableBinary(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves all variables of a given task by id.
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValues] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  **Note:** While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public getTaskLocalVariables(id: string, deserializeValues?: boolean, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).getTaskLocalVariables(id, deserializeValues, options)(this.fetch, this.basePath);
    }

    /**
     * Updates or deletes the variables in the context of a task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update.
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public modifyTaskLocalVariables(id: string, body?: PatchVariablesDto, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).modifyTaskLocalVariables(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets a variable in the context of a given task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public putTaskLocalVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).putTaskLocalVariable(id, varName, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable.
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {Blob} [data] 
     * @param {string} [valueType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskLocalVariableApi
     */
    public setBinaryTaskLocalVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
        return TaskLocalVariableApiFp(this.configuration).setBinaryTaskLocalVariable(id, varName, data, valueType, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskVariableApi - fetch parameter creator
 * @export
 */
export const TaskVariableApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTaskVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling deleteTaskVariable.');
            }
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getTaskVariable.');
            }
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary(id: string, varName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskVariableBinary.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling getTaskVariableBinary.');
            }
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables(id: string, deserializeValue?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getTaskVariables.');
            }
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (deserializeValue !== undefined) {
                localVarQueryParameter['deserializeValue'] = deserializeValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables(id: string, body?: PatchVariablesDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling modifyTaskVariables.');
            }
            const localVarPath = `/task/{id}/variables`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"PatchVariablesDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn't exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable(id: string, varName: string, body?: VariableValueDto, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling putTaskVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling putTaskVariable.');
            }
            const localVarPath = `/task/{id}/variables/{varName}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"VariableValueDto" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable(id: string, varName: string, data?: Blob, valueType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling setBinaryTaskVariable.');
            }
            // verify required parameter 'varName' is not null or undefined
            if (varName === null || varName === undefined) {
                throw new RequiredError('varName','Required parameter varName was null or undefined when calling setBinaryTaskVariable.');
            }
            const localVarPath = `/task/{id}/variables/{varName}/data`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"varName"}}`, encodeURIComponent(String(varName)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            if (data !== undefined) {
                localVarFormParams.set('data', data as any);
            }

            if (valueType !== undefined) {
                localVarFormParams.set('valueType', valueType as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskVariableApi - functional programming interface
 * @export
 */
export const TaskVariableApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).deleteTaskVariable(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VariableValueDto> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).getTaskVariable(id, varName, deserializeValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary(id: string, varName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).getTaskVariableBinary(id, varName, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables(id: string, deserializeValue?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: VariableValueDto; }> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).getTaskVariables(id, deserializeValue, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables(id: string, body?: PatchVariablesDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).modifyTaskVariables(id, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn't exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable(id: string, varName: string, body?: VariableValueDto, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).putTaskVariable(id, varName, body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskVariableApiFetchParamCreator(configuration).setBinaryTaskVariable(id, varName, data, valueType, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskVariableApi - factory interface
 * @export
 */
export const TaskVariableApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to delete the variable from.
         * @param {string} varName The name of the variable to be removed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaskVariable(id: string, varName: string, options?: any) {
            return TaskVariableApiFp(configuration).deleteTaskVariable(id, varName, options)(fetch, basePath);
        },
        /**
         * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable from.
         * @param {string} varName The name of the variable to get.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
            return TaskVariableApiFp(configuration).getTaskVariable(id, varName, deserializeValue, options)(fetch, basePath);
        },
        /**
         * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariableBinary(id: string, varName: string, options?: any) {
            return TaskVariableApiFp(configuration).getTaskVariableBinary(id, varName, options)(fetch, basePath);
        },
        /**
         * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variables from.
         * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaskVariables(id: string, deserializeValue?: boolean, options?: any) {
            return TaskVariableApiFp(configuration).getTaskVariables(id, deserializeValue, options)(fetch, basePath);
        },
        /**
         * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to set variables for.
         * @param {PatchVariablesDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTaskVariables(id: string, body?: PatchVariablesDto, options?: any) {
            return TaskVariableApiFp(configuration).modifyTaskVariables(id, body, options)(fetch, basePath);
        },
        /**
         * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn't exist, the variable is created in the top-most scope visible from the task.
         * @param {string} id The id of the task to set the variable for.
         * @param {string} varName The name of the variable to set.
         * @param {VariableValueDto} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putTaskVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
            return TaskVariableApiFp(configuration).putTaskVariable(id, varName, body, options)(fetch, basePath);
        },
        /**
         * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
         * @param {string} id The id of the task to retrieve the variable for.
         * @param {string} varName The name of the variable to retrieve.
         * @param {Blob} [data] 
         * @param {string} [valueType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setBinaryTaskVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
            return TaskVariableApiFp(configuration).setBinaryTaskVariable(id, varName, data, valueType, options)(fetch, basePath);
        },
    };
};

/**
 * TaskVariableApi - object-oriented interface
 * @export
 * @class TaskVariableApi
 * @extends {BaseAPI}
 */
export class TaskVariableApi extends BaseAPI {
    /**
     * Removes a variable that is visible to a task. A variable is visible to a task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to delete the variable from.
     * @param {string} varName The name of the variable to be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public deleteTaskVariable(id: string, varName: string, options?: any) {
        return TaskVariableApiFp(this.configuration).deleteTaskVariable(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a variable from the context of a given task. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable from.
     * @param {string} varName The name of the variable to get.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;).  If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariable(id: string, varName: string, deserializeValue?: boolean, options?: any) {
        return TaskVariableApiFp(this.configuration).getTaskVariable(id, varName, deserializeValue, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves a binary variable from the context of a given task. Applicable for byte array and file variables. The variable must be visible from the task. It is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariableBinary(id: string, varName: string, options?: any) {
        return TaskVariableApiFp(this.configuration).getTaskVariableBinary(id, varName, options)(this.fetch, this.basePath);
    }

    /**
     * Retrieves all variables visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variables from.
     * @param {boolean} [deserializeValue] Determines whether serializable variable values (typically variables that store custom Java objects) should be deserialized on the server side (default &#x60;true&#x60;). If set to &#x60;true&#x60;, a serializable variable will be deserialized on server side and transformed to JSON using [Jackson&#x27;s](https://github.com/FasterXML/jackson) POJO/bean property introspection feature. Note that this requires the Java classes of the variable value to be on the REST API&#x27;s classpath.  If set to &#x60;false&#x60;, a serializable variable will be returned in its serialized format. For example, a variable that is serialized as XML will be returned as a JSON string containing XML.  Note: While &#x60;true&#x60; is the default value for reasons of backward compatibility, we recommend setting this parameter to &#x60;false&#x60; when developing web applications that are independent of the Java process applications deployed to the engine.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public getTaskVariables(id: string, deserializeValue?: boolean, options?: any) {
        return TaskVariableApiFp(this.configuration).getTaskVariables(id, deserializeValue, options)(this.fetch, this.basePath);
    }

    /**
     * Updates or deletes the variables visible from the task. Updates precede deletions. So, if a variable is updated AND deleted, the deletion overrides the update. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to set variables for.
     * @param {PatchVariablesDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public modifyTaskVariables(id: string, body?: PatchVariablesDto, options?: any) {
        return TaskVariableApiFp(this.configuration).modifyTaskVariables(id, body, options)(this.fetch, this.basePath);
    }

    /**
     * Updates a process variable that is visible from the Task scope. A variable is visible from the task if it is a local task variable, or declared in a parent scope of the task. See the documentation on [variable scopes and visibility](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables#variable-scopes-and-variable-visibility).  **Note**: If a variable doesn't exist, the variable is created in the top-most scope visible from the task.
     * @param {string} id The id of the task to set the variable for.
     * @param {string} varName The name of the variable to set.
     * @param {VariableValueDto} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public putTaskVariable(id: string, varName: string, body?: VariableValueDto, options?: any) {
        return TaskVariableApiFp(this.configuration).putTaskVariable(id, varName, body, options)(this.fetch, this.basePath);
    }

    /**
     * Sets the serialized value for a binary variable or the binary value for a file variable visible from the task. A variable is visible from the task if it is a local task variable or declared in a parent scope of the task. See documentation on [visiblity of variables](https://docs.camunda.org/manual/7.13/user-guide/process-engine/variables/).
     * @param {string} id The id of the task to retrieve the variable for.
     * @param {string} varName The name of the variable to retrieve.
     * @param {Blob} [data] 
     * @param {string} [valueType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskVariableApi
     */
    public setBinaryTaskVariable(id: string, varName: string, data?: Blob, valueType?: string, options?: any) {
        return TaskVariableApiFp(this.configuration).setBinaryTaskVariable(id, varName, data, valueType, options)(this.fetch, this.basePath);
    }

}
/**
 * VersionApi - fetch parameter creator
 * @export
 */
export const VersionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion(options: any = {}): FetchArgs {
            const localVarPath = `/version`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<VersionDto> {
            const localVarFetchArgs = VersionApiFetchParamCreator(configuration).getRestAPIVersion(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Retrieves the version of the Rest API.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRestAPIVersion(options?: any) {
            return VersionApiFp(configuration).getRestAPIVersion(options)(fetch, basePath);
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * Retrieves the version of the Rest API.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public getRestAPIVersion(options?: any) {
        return VersionApiFp(this.configuration).getRestAPIVersion(options)(this.fetch, this.basePath);
    }

}
